<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IA Ultra Avanzada V2 - An√°lisis Sem√°ntico Profundo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header .badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            margin: 5px;
            font-size: 0.9em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }

        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
        }

        .btn-info {
            background: linear-gradient(135deg, #2196F3 0%, #0d8bf2 100%);
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .btn-delete {
            background: #f44336;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
        }

        .btn-delete:hover {
            background: #d32f2f;
            transform: scale(1.05);
        }

        .response-box {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #667eea;
            min-height: 150px;
            margin-top: 15px;
            max-height: 500px;
            overflow-y: auto;
        }

        .training-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
        }

        .training-content {
            flex: 1;
        }

        .training-item strong {
            color: #667eea;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .stat-card .number {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-card .label {
            color: #666;
            margin-top: 5px;
        }

        .status {
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
            font-weight: 600;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }

        .status.warning {
            background: #fff3cd;
            color: #856404;
        }

        .analysis {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid #2196F3;
        }

        .analysis-item {
            margin: 5px 0;
            color: #0d47a1;
        }

        .match-score {
            display: inline-block;
            background: #4caf50;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .combined-badge {
            display: inline-block;
            background: #ff9800;
            color: white;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: bold;
            margin-left: 10px;
        }

        .source-list {
            background: #f0f4f8;
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
            font-size: 0.9em;
        }

        .source-item {
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        .source-weight {
            display: inline-block;
            background: #e3f2fd;
            color: #1976d2;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .auto-tags {
            background: #f0f8ff;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .auto-tags span {
            display: inline-block;
            background: #e1f5fe;
            padding: 3px 8px;
            border-radius: 12px;
            margin: 2px;
            font-size: 0.8em;
        }

        .correction-box {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .correction-box h4 {
            color: #856404;
            margin-bottom: 8px;
        }

        .correction-item {
            background: white;
            padding: 6px 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #ff9800;
        }

        .correction-item .before {
            text-decoration: line-through;
            color: #d32f2f;
        }

        .correction-item .after {
            color: #388e3c;
            font-weight: bold;
        }

        .feedback-btns {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .feedback-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: transform 0.2s;
        }

        .feedback-btn:hover {
            transform: scale(1.05);
        }

        .feedback-good {
            background: #4caf50;
            color: white;
        }

        .feedback-bad {
            background: #f44336;
            color: white;
        }

        #fileInput {
            display: none;
        }

        .storage-warning {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 15px;
            border-radius: 8px;
            margin: 20px;
            text-align: center;
        }

        .storage-warning h3 {
            color: #856404;
            margin-bottom: 10px;
        }

        .storage-warning p {
            color: #856404;
            margin: 5px 0;
        }

        .generated-response {
            background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
            padding: 18px;
            border-radius: 10px;
            margin: 12px 0;
            border-left: 4px solid #4caf50;
            line-height: 1.8;
            font-size: 1.05em;
        }

        .coherence-badge {
            display: inline-block;
            background: #9c27b0;
            color: white;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: bold;
            margin-left: 10px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .btn-group {
                grid-template-columns: 1fr;
            }

            .training-item {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† IA Ultra Avanzada V2</h1>
            <p>An√°lisis Sem√°ntico Profundo + Generaci√≥n Coherente Inteligente</p>
            <div>
                <span class="badge">‚úçÔ∏è Auto-Correcci√≥n</span>
                <span class="badge">üîÄ Combinaci√≥n Inteligente</span>
                <span class="badge">üìù An√°lisis de Coherencia</span>
                <span class="badge">üéØ Detecci√≥n de Incompatibilidades</span>
                <span class="badge">üß© Filtrado de Calidad</span>
            </div>
        </div>

        <div id="storageWarning" class="storage-warning" style="display:none;">
            <h3>‚ö†Ô∏è Aviso Importante</h3>
            <p><strong>Descarga este archivo para guardar permanentemente.</strong></p>
            <p>Clic derecho ‚Üí "Guardar como" ‚Üí Abre desde tu PC</p>
        </div>

        <div class="main-content">
            <div class="section">
                <h2>üìö Entrenar IA</h2>
                <div class="input-group">
                    <label for="question">Pregunta / Entrada:</label>
                    <textarea id="question" placeholder="Escribe aqu√≠... (La IA corregir√° autom√°ticamente)"></textarea>
                </div>
                <div class="input-group">
                    <label for="answer">Respuesta / Salida:</label>
                    <textarea id="answer" placeholder="Escribe la respuesta... (Se corregir√° al guardar)"></textarea>
                </div>
                <div id="corrections" class="correction-box" style="display:none;"></div>
                <div id="autoTags" class="auto-tags" style="display:none;">
                    <strong>Palabras clave:</strong> <span id="tagsList"></span>
                </div>
                <button class="btn" onclick="trainAI()">‚úÖ Entrenar IA (con correcci√≥n)</button>
                <button class="btn btn-secondary" onclick="viewTraining()">Ver Entrenamiento</button>
                
                <div class="btn-group">
                    <button class="btn btn-success" onclick="downloadTraining()">üì• Descargar</button>
                    <button class="btn btn-info" onclick="document.getElementById('fileInput').click()">üì§ Cargar</button>
                </div>
                <input type="file" id="fileInput" accept=".json" onchange="loadTraining(event)">
                
                <button class="btn btn-danger" onclick="clearAllTraining()">üóëÔ∏è Borrar Todo</button>
                <div id="trainStatus"></div>
            </div>

            <div class="section">
                <h2>üí¨ Consultar IA</h2>
                <div class="input-group">
                    <label for="userQuestion">Pregunta:</label>
                    <textarea id="userQuestion" placeholder="Escribe tu pregunta... La IA generar√° respuestas inteligentes y coherentes"></textarea>
                </div>
                <button class="btn" onclick="askAI()">üöÄ Consultar</button>
                <div class="response-box" id="aiResponse">
                    La IA analizar√° profundamente tu pregunta con detecci√≥n de incompatibilidades, an√°lisis de coherencia y filtrado de calidad para generar la mejor respuesta posible...
                </div>
                <div id="feedbackSection"></div>
                <div id="analysis"></div>
            </div>

            <div class="section" style="grid-column: 1 / -1;">
                <h2>üìä Estad√≠sticas</h2>
                <div class="stats">
                    <div class="stat-card">
                        <div class="number" id="totalTraining">0</div>
                        <div class="label">Entrenamientos</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="totalWords">0</div>
                        <div class="label">Palabras √önicas</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="totalQuestions">0</div>
                        <div class="label">Consultas</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="dbSize">0 KB</div>
                        <div class="label">Tama√±o BD</div>
                    </div>
                </div>
            </div>

            <div class="section" style="grid-column: 1 / -1;">
                <h2>üìù Base de Conocimiento</h2>
                <div id="trainingList"></div>
            </div>
        </div>
    </div>

    <script>
        let trainingData = [];
        let questionCount = 0;
        let conversationContext = [];
        let lastUsedSources = [];
        let storageAvailable = false;

        const synonyms = {
            'hola': ['saludos', 'buenas', 'hey', 'alo', 'que tal'],
            'adios': ['chao', 'hasta luego', 'nos vemos', 'bye'],
            'gracias': ['muchas gracias', 'agradecido', 'thanks'],
            'ayuda': ['ayudar', 'asistencia', 'soporte', 'auxilio'],
            'como': ['de que manera', 'de que forma'],
            'que': ['cual', 'cuales'],
            'hacer': ['realizar', 'ejecutar', 'crear'],
            'bueno': ['bien', 'excelente', 'genial', 'perfecto'],
            'malo': ['mal', 'pesimo', 'terrible'],
            'programar': ['programacion', 'codificar', 'codigo', 'desarrollar'],
            'javascript': ['js', 'ecmascript'],
            'python': ['py'],
            'aprender': ['estudiar', 'ensenar', 'educacion']
        };

        const spellingCorrections = {
            'q': 'que', 'xq': 'porque', 'pq': 'porque', 'xk': 'porque',
            'tb': 'tambi√©n', 'tmb': 'tambi√©n', 'bn': 'bien',
            'd': 'de', 'k': 'que', 'x': 'por', 'pa': 'para',
            'porfa': 'por favor', 'porfavor': 'por favor',
            'hola': 'hola', 'ola': 'hola',
            'aver': 'a ver', 'aber': 'a ver',
            'aslo': 'hazlo', 'ase': 'hace', 'ahy': 'ah√≠',
            'q': 'qu√©', 'komo': 'como', 'kien': 'quien',
            'xfa': 'por favor', 'porq': 'porque',
            'entiendes': 'entiendes', 'bn': 'bien',
            'bro': 'hermano', 'wey': 'amigo'
        };

        const accentCorrections = {
            'como': 'c√≥mo', 'que': 'qu√©', 'cual': 'cu√°l', 'donde': 'd√≥nde',
            'cuando': 'cu√°ndo', 'quien': 'qui√©n', 'cuanto': 'cu√°nto',
            'mas': 'm√°s', 'si': 's√≠', 'tu': 't√∫', 'mi': 'm√≠',
            'te': 't√©', 'el': '√©l', 'solo': 's√≥lo',
            'esta': 'est√°', 'estas': 'est√°s', 'este': 'este',
            'razon': 'raz√≥n', 'acion': 'aci√≥n', 'informacion': 'informaci√≥n',
            'codigo': 'c√≥digo', 'tambien': 'tambi√©n', 'ahi': 'ah√≠',
            'dia': 'd√≠a', 'despues': 'despu√©s', 'facil': 'f√°cil',
            'dificil': 'dif√≠cil', 'util': '√∫til', 'semantica': 'sem√°ntica'
        };

        function checkStorageAvailability() {
            try {
                const test = '__storage_test__';
                localStorage.setItem(test, test);
                localStorage.removeItem(test);
                storageAvailable = true;
                return true;
            } catch(e) {
                storageAvailable = false;
                document.getElementById('storageWarning').style.display = 'block';
                return false;
            }
        }

        function saveToStorage() {
            if (!storageAvailable) return;
            try {
                const dataToSave = {
                    trainingData: trainingData,
                    questionCount: questionCount,
                    lastSaved: new Date().toISOString()
                };
                localStorage.setItem('aiTrainingData', JSON.stringify(dataToSave));
            } catch(e) {
                console.warn('No se pudo guardar:', e);
            }
        }

        function loadFromStorage() {
            if (!storageAvailable) return;
            try {
                const saved = localStorage.getItem('aiTrainingData');
                if (saved) {
                    const data = JSON.parse(saved);
                    trainingData = data.trainingData || [];
                    questionCount = data.questionCount || 0;
                    const statusDiv = document.getElementById('trainStatus');
                    statusDiv.innerHTML = `<div class="status success">‚úì ${trainingData.length} entrenamientos cargados</div>`;
                    setTimeout(() => { statusDiv.innerHTML = ''; }, 3000);
                }
            } catch(e) {
                console.warn('Error al cargar:', e);
            }
        }

        function correctSpelling(text) {
            let corrected = text;
            const corrections = [];
            
            const words = text.split(/\s+/);
            
            words.forEach(word => {
                const cleanWord = word.toLowerCase().replace(/[.,!?;:]/g, '');
                
                if (spellingCorrections[cleanWord]) {
                    const replacement = spellingCorrections[cleanWord];
                    corrected = corrected.replace(new RegExp('\\b' + word + '\\b', 'gi'), replacement);
                    corrections.push({ before: word, after: replacement });
                }
            });
            
            return { text: corrected, corrections };
        }

        function addAccents(text) {
            let corrected = text;
            const corrections = [];
            
            const isQuestion = text.includes('?') || 
                              /^(como|que|cual|donde|cuando|quien|cuanto)/i.test(text);
            
            if (isQuestion) {
                Object.entries(accentCorrections).forEach(([without, with_]) => {
                    const regex = new RegExp('\\b' + without + '\\b', 'gi');
                    if (regex.test(corrected)) {
                        corrected = corrected.replace(regex, with_);
                        corrections.push({ before: without, after: with_ });
                    }
                });
            }
            
            return { text: corrected, corrections };
        }

        function addPunctuation(text) {
            let corrected = text.trim();
            const corrections = [];
            
            if (!/[.!?]$/.test(corrected)) {
                corrections.push({ before: 'sin punto final', after: 'con punto final' });
                corrected += '.';
            }
            
            if (corrected.length > 0 && corrected[0] !== corrected[0].toUpperCase()) {
                corrections.push({ before: 'min√∫scula inicial', after: 'may√∫scula inicial' });
                corrected = corrected.charAt(0).toUpperCase() + corrected.slice(1);
            }
            
            corrected = corrected.replace(/\.([a-z√°√©√≠√≥√∫√±])/gi, '. $1');
            corrected = corrected.replace(/,([a-z√°√©√≠√≥√∫√±])/gi, ', $1');
            
            corrected = corrected.replace(/\.\s+([a-z√°√©√≠√≥√∫√±])/g, (match, letter) => {
                return '. ' + letter.toUpperCase();
            });
            
            return { text: corrected, corrections };
        }

        function fullCorrection(text) {
            if (!text || text.trim() === '') return { text: '', corrections: [] };
            
            let allCorrections = [];
            
            const spelling = correctSpelling(text);
            let result = spelling.text;
            allCorrections = allCorrections.concat(spelling.corrections);
            
            const accents = addAccents(result);
            result = accents.text;
            allCorrections = allCorrections.concat(accents.corrections);
            
            const punctuation = addPunctuation(result);
            result = punctuation.text;
            allCorrections = allCorrections.concat(punctuation.corrections);
            
            return { text: result, corrections: allCorrections };
        }

        function showCorrections(corrections) {
            const corrDiv = document.getElementById('corrections');
            
            if (corrections.length === 0) {
                corrDiv.style.display = 'none';
                return;
            }
            
            let html = '<h4>‚úçÔ∏è Correcciones aplicadas:</h4>';
            corrections.forEach(corr => {
                html += `
                    <div class="correction-item">
                        <span class="before">${corr.before}</span> ‚Üí 
                        <span class="after">${corr.after}</span>
                    </div>
                `;
            });
            
            corrDiv.innerHTML = html;
            corrDiv.style.display = 'block';
        }

        function normalizeText(text) {
            return text.toLowerCase()
                .normalize("NFD")
                .replace(/[\u0300-\u036f]/g, "")
                .replace(/[^\w\s]/g, " ")
                .replace(/\s+/g, " ")
                .trim();
        }

        function stem(word) {
            const suffixes = ['ando', 'iendo', 'mente', 'aci√≥n', 'ador', 'ante', 'ancia', 'encia', 
                            'ible', 'able', 'ismo', 'ista', 'oso', 'osa', 'ivo', 'iva',
                            'ar', 'er', 'ir', 'ado', 'ido', 'es', 'as', 'os', 's'];
            
            for (let suffix of suffixes) {
                if (word.length > suffix.length + 3 && word.endsWith(suffix)) {
                    return word.slice(0, -suffix.length);
                }
            }
            return word;
        }

        function tokenize(text) {
            const normalized = normalizeText(text);
            const words = normalized.split(/\s+/).filter(w => w.length > 0);
            const stems = words.map(w => stem(w));
            
            const bigrams = [];
            const trigrams = [];
            for (let i = 0; i < words.length - 1; i++) {
                bigrams.push(words[i] + ' ' + words[i + 1]);
                if (i < words.length - 2) {
                    trigrams.push(words[i] + ' ' + words[i + 1] + ' ' + words[i + 2]);
                }
            }
            
            return { words, stems, normalized, bigrams, trigrams };
        }

        function extractKeywords(text) {
            const { words } = tokenize(text);
            
            const commonWords = new Set([
                'que', 'qu√©', 'como', 'c√≥mo', 'para', 'por', 'con', 'de', 'en', 'la', 'el', 'los', 'las',
                'un', 'una', 'unos', 'unas', 'y', 'o', 'pero', 'si', 'no', 'es', 'son', 'soy', 'eres',
                'esta', 'este', 'estos', 'estas', 'al', 'del', 'lo', 'le', 'se', 'te', 'me', 'nos', 'os',
                'su', 'sus', 'mi', 'mis', 'tu', 'tus', 'a', 'ante', 'bajo', 'desde', 'entre', 'hacia',
                'hasta', 'seg√∫n', 'sin', 'sobre', 'tras', 'ser', 'estar', 'hay', 'tener'
            ]);
            
            const keywords = words.filter(word => word.length > 2 && !commonWords.has(word));
            
            const expandedKeywords = new Set(keywords);
            keywords.forEach(keyword => {
                if (synonyms[keyword]) {
                    synonyms[keyword].forEach(syn => expandedKeywords.add(syn));
                }
                Object.entries(synonyms).forEach(([key, syns]) => {
                    if (syns.includes(keyword)) {
                        expandedKeywords.add(key);
                    }
                });
            });
            
            return [...expandedKeywords];
        }

        function levenshtein(str1, str2) {
            const len1 = str1.length;
            const len2 = str2.length;
            const matrix = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));

            for (let i = 0; i <= len1; i++) matrix[i][0] = i;
            for (let j = 0; j <= len2; j++) matrix[0][j] = j;

            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1,
                        matrix[i][j - 1] + 1,
                        matrix[i - 1][j - 1] + cost
                    );
                }
            }

            const maxLen = Math.max(len1, len2);
            return maxLen === 0 ? 1 : 1 - (matrix[len1][len2] / maxLen);
        }

        function calculateSimilarity(text1, text2) {
            const tokens1 = tokenize(text1);
            const tokens2 = tokenize(text2);
            
            const set1 = new Set(tokens1.words);
            const set2 = new Set(tokens2.words);
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            const jaccard = union.size === 0 ? 0 : intersection.size / union.size;
            
            const levSim = levenshtein(tokens1.normalized, tokens2.normalized);
            
            const stemSet1 = new Set(tokens1.stems);
            const stemSet2 = new Set(tokens2.stems);
            const stemIntersection = new Set([...stemSet1].filter(x => stemSet2.has(x)));
            const stemUnion = new Set([...stemSet1, ...stemSet2]);
            const stemSim = stemUnion.size === 0 ? 0 : stemIntersection.size / stemUnion.size;
            
            const bigramSet1 = new Set(tokens1.bigrams);
            const bigramSet2 = new Set(tokens2.bigrams);
            const bigramIntersection = new Set([...bigramSet1].filter(x => bigramSet2.has(x)));
            const bigramUnion = new Set([...bigramSet1, ...bigramSet2]);
            const bigramSim = bigramUnion.size === 0 ? 0 : bigramIntersection.size / bigramUnion.size;
            
            let containsSim = 0;
            if (tokens1.normalized.includes(tokens2.normalized) || tokens2.normalized.includes(tokens1.normalized)) {
                const shorter = Math.min(tokens1.normalized.length, tokens2.normalized.length);
                const longer = Math.max(tokens1.normalized.length, tokens2.normalized.length);
                containsSim = shorter / longer;
            }
            
            return (jaccard * 0.25 + levSim * 0.25 + stemSim * 0.20 + bigramSim * 0.20 + containsSim * 0.10) * 100;
        }

        function detectQuestionType(text) {
            const lower = text.toLowerCase();
            
            if (/^(hola|buenas|saludos|hey|que tal|como estas)/i.test(lower)) {
                return 'saludo';
            }
            if (/^(adios|chao|hasta luego|nos vemos)/i.test(lower)) {
                return 'despedida';
            }
            if (/^(gracias|agradecido|te agradezco)/i.test(lower)) {
                return 'agradecimiento';
            }
            if (/(que es|que significa|define|explicame|que son)/i.test(lower)) {
                return 'definici√≥n';
            }
            if (/(como|de que manera|de que forma|pasos para)/i.test(lower)) {
                return 'instrucci√≥n';
            }
            if (/(por que|cual es la razon|por que motivo)/i.test(lower)) {
                return 'explicaci√≥n';
            }
            if (/(cuando|en que momento|a que hora)/i.test(lower)) {
                return 'temporal';
            }
            if (/(donde|en que lugar|en que sitio)/i.test(lower)) {
                return 'ubicaci√≥n';
            }
            if (/(quien|quienes|que persona)/i.test(lower)) {
                return 'identidad';
            }
            if (/(sabes|conoces|tienes|puedes)/i.test(lower)) {
                return 'capacidad';
            }
            
            return 'general';
        }

        function extractTopics(text) {
            const topicKeywords = {
                'technology': ['internet', 'computadora', 'programa', 'c√≥digo', 'software', 'app', 'web'],
                'conversation': ['hola', 'gracias', 'bien', 'mal', 'c√≥mo', 'qu√© tal', 'bro', 'amigo'],
                'learning': ['aprender', 'estudiar', 'ense√±ar', 'educaci√≥n', 'curso', 'tutorial'],
                'work': ['trabajo', 'empleo', 'profesi√≥n', 'carrera', 'especialista'],
                'personal': ['yo', 't√∫', 'nosotros', 'mi', 'tu', 'nuestro']
            };
            
            const lower = text.toLowerCase();
            const foundTopics = [];
            
            Object.entries(topicKeywords).forEach(([topic, keywords]) => {
                if (keywords.some(keyword => lower.includes(keyword))) {
                    foundTopics.push(topic);
                }
            });
            
            return foundTopics;
        }

        function areIncompatible(sent1, sent2) {
            const lower1 = sent1.toLowerCase();
            const lower2 = sent2.toLowerCase();
            
            const hasNot1 = /\b(no|nunca|jam√°s|nadie|nada)\b/.test(lower1);
            const hasNot2 = /\b(no|nunca|jam√°s|nadie|nada)\b/.test(lower2);
            
            if (hasNot1 !== hasNot2) {
                const similarity = calculateSimilarity(sent1, sent2);
                if (similarity > 40) return true;
            }
            
            const isGreeting1 = /\b(hola|buenas|saludos|hey)\b/.test(lower1);
            const isFarewell1 = /\b(adios|chao|hasta luego|nos vemos)\b/.test(lower1);
            const isGreeting2 = /\b(hola|buenas|saludos|hey)\b/.test(lower2);
            const isFarewell2 = /\b(adios|chao|hasta luego|nos vemos)\b/.test(lower2);
            
            if ((isGreeting1 && isFarewell2) || (isFarewell1 && isGreeting2)) return true;
            
            const topics1 = extractTopics(sent1);
            const topics2 = extractTopics(sent2);
            const commonTopics = topics1.filter(t => topics2.includes(t));
            
            if (topics1.length > 0 && topics2.length > 0 && commonTopics.length === 0) {
                return true;
            }
            
            const isConversational1 = /\b(xd|jaja|lol|bro|tu|gracias|genial)\b/.test(lower1);
            const isTechnical1 = /\b(especializa|materia|t√©cnica|sistema|proceso|m√©todo)\b/.test(lower1);
            const isConversational2 = /\b(xd|jaja|lol|bro|tu|gracias|genial)\b/.test(lower2);
            const isTechnical2 = /\b(especializa|materia|t√©cnica|sistema|proceso|m√©todo)\b/.test(lower2);
            
            if ((isConversational1 && isTechnical2) || (isTechnical1 && isConversational2)) {
                return true;
            }
            
            return false;
        }

        function calculateCompleteness(sentence) {
            let score = 0;
            
            if (sentence.length < 15) return 20;
            if (sentence.length > 40) score += 30;
            
            const hasVerb = /\b(es|son|est√°|est√°n|tiene|tienen|pueden|hace|hago|debo|puede|sabe|hacer|ser|estar)\b/i.test(sentence);
            if (hasVerb) score += 25;
            
            const hasSubject = /\b(yo|t√∫|√©l|ella|nosotros|esto|eso|la|el|un|una)\b/i.test(sentence);
            if (hasSubject) score += 20;
            
            const isFragment = /^(xd|jaja|lol|bien|mal|si|no|ok)\.?$/i.test(sentence.trim());
            if (isFragment) return 10;
            
            if (/[.!?]$/.test(sentence)) score += 15;
            
            const hasErrors = /\b(ah|lose|ase)\b/i.test(sentence);
            if (hasErrors) score -= 20;
            
            return Math.max(0, Math.min(100, score));
        }

        function calculateCoherence(sentence1, sentence2) {
            if (areIncompatible(sentence1, sentence2)) {
                return 5;
            }
            
            const similarity = calculateSimilarity(sentence1, sentence2);
            
            const connectors = ['adem√°s', 'tambi√©n', 'por lo tanto', 'sin embargo', 'pero', 'y', 'asimismo', 'por otro lado'];
            let hasConnector = connectors.some(conn => sentence2.toLowerCase().includes(conn));
            
            const words1 = new Set(tokenize(sentence1).words);
            const words2 = new Set(tokenize(sentence2).words);
            const commonWords = [...words1].filter(w => words2.has(w)).length;
            
            if (similarity > 90) return 15;
            
            const topics1 = extractTopics(sentence1);
            const topics2 = extractTopics(sentence2);
            const commonTopics = topics1.filter(t => topics2.includes(t)).length;
            
            let coherence = 30;
            coherence += (similarity * 0.25);
            coherence += (hasConnector ? 20 : 0);
            coherence += (commonWords * 8);
            coherence += (commonTopics * 15);
            
            const complete1 = calculateCompleteness(sentence1);
            const complete2 = calculateCompleteness(sentence2);
            if (complete1 > 60 && complete2 > 60) {
                coherence += 10;
            }
            
            return Math.min(coherence, 100);
        }

        function findMatches(userInput) {
            const matches = [];
            const userTokens = tokenize(userInput);
            const userKeywords = extractKeywords(userInput);
            
            trainingData.forEach((item, index) => {
                let score = 0;
                const details = [];
                
                const qSimilarity = calculateSimilarity(userInput, item.question);
                score += qSimilarity * 0.5;
                if (qSimilarity > 5) details.push(`Pregunta: ${qSimilarity.toFixed(0)}%`);
                
                const aSimilarity = calculateSimilarity(userInput, item.answer);
                score += aSimilarity * 0.15;
                if (aSimilarity > 5) details.push(`Respuesta: ${aSimilarity.toFixed(0)}%`);
                
                const keywordMatches = [];
                userKeywords.forEach(userKw => {
                    item.keywords.forEach(itemKw => {
                        if (userKw === itemKw || 
                            (synonyms[userKw] && synonyms[userKw].includes(itemKw)) ||
                            (synonyms[itemKw] && synonyms[itemKw].includes(userKw))) {
                            keywordMatches.push(itemKw);
                        }
                    });
                });
                
                if (keywordMatches.length > 0) {
                    score += keywordMatches.length * 8;
                    details.push(`Keywords: ${keywordMatches.length}`);
                }
                
                const bigramMatches = item.questionBigrams.filter(bg => userTokens.bigrams.includes(bg));
                if (bigramMatches.length > 0) {
                    score += bigramMatches.length * 15;
                    details.push(`Bigramas: ${bigramMatches.length}`);
                }
                
                const trigramMatches = item.questionTrigrams.filter(tg => userTokens.trigrams.includes(tg));
                if (trigramMatches.length > 0) {
                    score += trigramMatches.length * 20;
                    details.push(`Trigramas: ${trigramMatches.length}`);
                }
                
                const stemMatches = item.questionStems.filter(stem => userTokens.stems.includes(stem));
                if (stemMatches.length > 0) {
                    score += stemMatches.length * 5;
                }
                
                if (item.successCount > 0) {
                    const successRate = item.successCount / (item.successCount + item.failCount || 1);
                    score += successRate * 10;
                    if (successRate > 0.5) details.push(`√âxito: ${(successRate * 100).toFixed(0)}%`);
                }
                
                if (conversationContext.length > 0) {
                    conversationContext.forEach(ctx => {
                        const ctxSim = calculateSimilarity(ctx, item.question);
                        if (ctxSim > 30) {
                            score += 15;
                            details.push('Contexto+');
                        }
                    });
                }
                
                if (score > 0) {
                    matches.push({ item, index, score: Math.min(score, 100), details });
                }
            });
            
            matches.sort((a, b) => b.score - a.score);
            return matches;
        }

        function generateCombinedResponse(userInput, matches) {
            if (matches.length === 0) return null;
            
            const topMatches = matches.slice(0, 8).filter(m => m.score > 15);
            
            if (topMatches.length === 0) return null;
            
            const questionType = detectQuestionType(userInput);
            
            if (topMatches.length === 1 && topMatches[0].score > 75) {
                const completeness = calculateCompleteness(topMatches[0].item.answer);
                if (completeness > 60) {
                    const corrected = fullCorrection(topMatches[0].item.answer);
                    return {
                        response: corrected.text,
                        combined: false,
                        sources: [topMatches[0]],
                        confidence: topMatches[0].score,
                        coherence: 100
                    };
                }
            }
            
            for (let match of topMatches.slice(0, 3)) {
                const completeness = calculateCompleteness(match.item.answer);
                if (match.score > 65 && completeness > 70) {
                    const corrected = fullCorrection(match.item.answer);
                    return {
                        response: corrected.text,
                        combined: false,
                        sources: [match],
                        confidence: match.score,
                        coherence: 100
                    };
                }
            }
            
            const weightedSources = topMatches.map(match => {
                const successRate = match.item.successCount / 
                    (match.item.successCount + match.item.failCount || 1);
                const weight = (match.score * 0.65) + (successRate * 100 * 0.35);
                
                return { ...match, weight, successRate };
            });
            
            weightedSources.sort((a, b) => b.weight - a.weight);
            
            const sentences = [];
            weightedSources.forEach(source => {
                const answerSentences = source.item.answer
                    .split(/[.!?]+/)
                    .map(s => s.trim())
                    .filter(s => s.length > 10);
                
                answerSentences.forEach(sentence => {
                    const relevance = calculateSimilarity(userInput, sentence);
                    const completeness = calculateCompleteness(sentence);
                    
                    const finalWeight = (source.weight * 0.4) + 
                                       (relevance * 0.35) + 
                                       (completeness * 0.25);
                    
                    sentences.push({
                        text: sentence,
                        weight: finalWeight,
                        source: source,
                        relevance: relevance,
                        completeness: completeness
                    });
                });
            });
            
            const qualitySentences = sentences.filter(s => s.completeness > 40);
            
            if (qualitySentences.length === 0) {
                return null;
            }
            
            const uniqueSentences = [];
            qualitySentences.forEach(sent => {
                const isDuplicate = uniqueSentences.some(unique => 
                    calculateSimilarity(sent.text, unique.text) > 75
                );
                if (!isDuplicate && sent.text.length > 10) {
                    uniqueSentences.push(sent);
                }
            });
            
            uniqueSentences.sort((a, b) => b.weight - a.weight);
            
            if (uniqueSentences.length > 0 && 
                uniqueSentences[0].weight > 70 && 
                uniqueSentences[0].completeness > 70) {
                const corrected = fullCorrection(uniqueSentences[0].text);
                return {
                    response: corrected.text,
                    combined: false,
                    sources: [uniqueSentences[0].source],
                    confidence: uniqueSentences[0].weight,
                    coherence: 100
                };
            }
            
            const selectedSentences = [uniqueSentences[0]];
            let totalCoherence = 100;
            let coherenceCount = 1;
            let rejectedCount = 0;
            
            for (let i = 1; i < Math.min(uniqueSentences.length, 8); i++) {
                const candidate = uniqueSentences[i];
                
                let minCoherence = 100;
                let isCompatible = true;
                
                for (let selected of selectedSentences) {
                    const coherence = calculateCoherence(selected.text, candidate.text);
                    minCoherence = Math.min(minCoherence, coherence);
                    
                    if (coherence < 50) {
                        isCompatible = false;
                        break;
                    }
                }
                
                if (isCompatible && minCoherence >= 50) {
                    selectedSentences.push(candidate);
                    totalCoherence += minCoherence;
                    coherenceCount++;
                    
                    if (selectedSentences.length >= 3) break;
                } else {
                    rejectedCount++;
                    if (rejectedCount > 5) break;
                }
            }
            
            if (selectedSentences.length === 1) {
                if (selectedSentences[0].completeness > 60) {
                    const corrected = fullCorrection(selectedSentences[0].text);
                    return {
                        response: corrected.text,
                        combined: false,
                        sources: [selectedSentences[0].source],
                        confidence: selectedSentences[0].weight,
                        coherence: 100
                    };
                } else {
                    return null;
                }
            }
            
            let combinedResponse = '';
            selectedSentences.forEach((sent, idx) => {
                if (idx === 0) {
                    combinedResponse += sent.text;
                } else {
                    const needsConnector = !sent.text.toLowerCase().startsWith('adem√°s') &&
                                          !sent.text.toLowerCase().startsWith('tambi√©n') &&
                                          !sent.text.toLowerCase().startsWith('por') &&
                                          !sent.text.toLowerCase().startsWith('sin embargo');
                    
                    if (needsConnector) {
                        const connectors = ['. Adem√°s, ', '. Tambi√©n, ', '. Asimismo, ', '. Por otro lado, '];
                        const selectedConnector = connectors[Math.floor(Math.random() * connectors.length)];
                        combinedResponse += selectedConnector + 
                                          sent.text.charAt(0).toLowerCase() + sent.text.slice(1);
                    } else {
                        combinedResponse += '. ' + sent.text;
                    }
                }
            });
            
            const finalCorrected = fullCorrection(combinedResponse);
            
            const avgWeight = selectedSentences.reduce((sum, s) => sum + s.weight, 0) / selectedSentences.length;
            const avgCoherence = totalCoherence / coherenceCount;
            
            if (avgCoherence < 50) {
                const corrected = fullCorrection(selectedSentences[0].text);
                return {
                    response: corrected.text,
                    combined: false,
                    sources: [selectedSentences[0].source],
                    confidence: selectedSentences[0].weight,
                    coherence: 100
                };
            }
            
            return {
                response: finalCorrected.text,
                combined: selectedSentences.length > 1,
                sources: selectedSentences.map(s => s.source),
                confidence: avgWeight,
                coherence: avgCoherence
            };
        }

        function trainAI() {
            const question = document.getElementById('question').value.trim();
            const answer = document.getElementById('answer').value.trim();
            const statusDiv = document.getElementById('trainStatus');

            if (!question || !answer) {
                statusDiv.innerHTML = '<div class="status error">Completa ambos campos</div>';
                return;
            }

            const qCorrected = fullCorrection(question);
            const aCorrected = fullCorrection(answer);
            
            const allCorrections = [...qCorrected.corrections, ...aCorrected.corrections];
            showCorrections(allCorrections);
            
            const correctedQuestion = qCorrected.text;
            const correctedAnswer = aCorrected.text;

            const { words: qWords, stems: qStems, bigrams: qBigrams, trigrams: qTrigrams } = tokenize(correctedQuestion);
            const { words: aWords, stems: aStems, bigrams: aBigrams, trigrams: aTrigrams } = tokenize(correctedAnswer);
            const keywords = extractKeywords(correctedQuestion + ' ' + correctedAnswer);
            
            trainingData.push({
                id: Date.now() + Math.random(),
                question: correctedQuestion,
                answer: correctedAnswer,
                questionNorm: normalizeText(correctedQuestion),
                answerNorm: normalizeText(correctedAnswer),
                questionWords: qWords,
                answerWords: aWords,
                questionStems: qStems,
                answerStems: aStems,
                questionBigrams: qBigrams,
                answerBigrams: aBigrams,
                questionTrigrams: qTrigrams,
                answerTrigrams: aTrigrams,
                keywords,
                successCount: 0,
                failCount: 0,
                useCount: 0,
                timestamp: new Date().toISOString()
            });

            saveToStorage();

            statusDiv.innerHTML = `<div class="status success">‚úì Entrenado${allCorrections.length > 0 ? ' y corregido' : ''}</div>`;
            document.getElementById('question').value = '';
            document.getElementById('answer').value = '';
            document.getElementById('autoTags').style.display = 'none';
            
            setTimeout(() => {
                document.getElementById('corrections').style.display = 'none';
            }, 5000);
            
            updateStats();
            viewTraining();
        }

        function deleteTraining(id) {
            if (!confirm('¬øEliminar?')) return;
            
            trainingData = trainingData.filter(item => item.id !== id);
            saveToStorage();
            
            const statusDiv = document.getElementById('trainStatus');
            statusDiv.innerHTML = '<div class="status success">‚úì Eliminado</div>';
            setTimeout(() => { statusDiv.innerHTML = ''; }, 2000);
            
            updateStats();
            viewTraining();
        }

        function askAI() {
            const userInput = document.getElementById('userQuestion').value.trim();
            const responseDiv = document.getElementById('aiResponse');
            const analysisDiv = document.getElementById('analysis');
            const feedbackDiv = document.getElementById('feedbackSection');

            if (!userInput) {
                responseDiv.innerHTML = '<div class="status error">Escribe algo</div>';
                return;
            }

            questionCount++;
            saveToStorage();

            if (trainingData.length === 0) {
                responseDiv.innerHTML = '<div class="status info">‚ö†Ô∏è Entrena la IA primero</div>';
                return;
            }

            const correctedInput = fullCorrection(userInput);
            const finalInput = correctedInput.text;

            const matches = findMatches(finalInput);

            if (matches.length === 0 || matches[0].score < 10) {
                responseDiv.innerHTML = '<div class="status info">ü§î Sin coincidencias relevantes. Entrena m√°s la IA con ejemplos similares.</div>';
                analysisDiv.innerHTML = '';
                feedbackDiv.innerHTML = '';
                lastUsedSources = [];
                
                conversationContext.push(finalInput);
                if (conversationContext.length > 5) conversationContext.shift();
            } else {
                const result = generateCombinedResponse(finalInput, matches);
                
                if (!result) {
                    const questionType = detectQuestionType(finalInput);
                    responseDiv.innerHTML = `
                        <div class="status warning">
                            ‚ö†Ô∏è No puedo generar una respuesta coherente con los datos disponibles.<br>
                            <small>Tipo detectado: ${questionType}. Entrena la IA con respuestas m√°s completas y espec√≠ficas.</small>
                        </div>
                    `;
                    
                    analysisDiv.innerHTML = `
                        <div class="analysis">
                            <strong>üîç An√°lisis:</strong><br>
                            <div class="analysis-item">‚Ä¢ ${matches.length} coincidencias encontradas</div>
                            <div class="analysis-item">‚Ä¢ Mejor coincidencia: ${matches[0].score.toFixed(0)}%</div>
                            <div class="analysis-item">‚Ä¢ Problema: Respuestas fragmentadas o incompatibles</div>
                            <div class="analysis-item">‚Ä¢ Soluci√≥n: Agrega respuestas m√°s completas y coherentes</div>
                        </div>
                    `;
                    feedbackDiv.innerHTML = '';
                    lastUsedSources = [];
                    return;
                }
                
                lastUsedSources = result.sources.map(s => s.index);
                
                let qualityColor = '#4caf50';
                let qualityText = 'Excelente';
                if (result.coherence < 70) {
                    qualityColor = '#ff9800';
                    qualityText = 'Buena';
                }
                if (result.coherence < 50) {
                    qualityColor = '#f44336';
                    qualityText = 'Aceptable';
                }
                
                let html = `
                    <div style="color: #155724;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                            <strong style="font-size: 1.1em;">ü§ñ Respuesta IA:</strong>
                            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                <span class="match-score">${result.confidence.toFixed(0)}% confianza</span>
                                ${result.combined ? '<span class="combined-badge">üîÄ COMBINADA</span>' : '<span class="combined-badge" style="background: #2196F3;">‚úì DIRECTA</span>'}
                                <span class="coherence-badge" style="background: ${qualityColor};">üìù ${result.coherence.toFixed(0)}% - ${qualityText}</span>
                            </div>
                        </div>
                        <div class="generated-response">
                            ${result.response}
                        </div>
                `;
                
                if (result.sources.length > 0) {
                    html += '<div class="source-list"><strong>üìö Fuentes utilizadas:</strong>';
                    result.sources.forEach((source, idx) => {
                        const successRate = source.item ? 
                            (source.item.successCount / (source.item.successCount + source.item.failCount || 1)) : 0;
                        html += `
                            <div class="source-item">
                                <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
                                    <div>
                                        <span class="source-weight">#${idx + 1} ${source.weight.toFixed(0)} pts</span>
                                        ${successRate > 0.7 ? '<span style="background: #4caf50; color: white; padding: 2px 6px; border-radius: 10px; font-size: 0.75em; margin-left: 5px;">‚úì Confiable</span>' : ''}
                                    </div>
                                </div>
                                <div style="margin-top: 5px; font-size: 0.9em;">"${source.item.question}"</div>
                            </div>
                        `;
                    });
                    html += '</div>';
                }
                
                html += '</div>';
                responseDiv.innerHTML = html;
                
                feedbackDiv.innerHTML = `
                    <div class="feedback-btns">
                        <button class="feedback-btn feedback-good" onclick="giveFeedback(true)">
                            üëç √ötil
                        </button>
                        <button class="feedback-btn feedback-bad" onclick="giveFeedback(false)">
                            üëé Incorrecta
                        </button>
                    </div>
                `;
                
                let analysisHTML = '<div class="analysis">';
                analysisHTML += '<strong>üîç An√°lisis del Proceso:</strong><br>';
                analysisHTML += `<div class="analysis-item">‚Ä¢ ${matches.length} fuentes analizadas (mejor: ${matches[0].score.toFixed(0)}%)</div>`;
                analysisHTML += `<div class="analysis-item">‚Ä¢ ${result.sources.length} fuentes utilizadas</div>`;
                analysisHTML += `<div class="analysis-item">‚Ä¢ Coherencia final: ${result.coherence.toFixed(0)}% (${result.coherence > 70 ? 'Excelente' : result.coherence > 50 ? 'Buena' : 'Aceptable'})</div>`;
                analysisHTML += `<div class="analysis-item">‚Ä¢ Tipo: ${result.combined ? 'Respuesta multi-fuente combinada' : 'Respuesta directa'}</div>`;
                analysisHTML += `<div class="analysis-item">‚Ä¢ Confianza: ${result.confidence.toFixed(0)}%</div>`;
                
                const questionType = detectQuestionType(finalInput);
                analysisHTML += `<div class="analysis-item">‚Ä¢ Pregunta tipo: ${questionType}</div>`;
                
                if (correctedInput.corrections.length > 0) {
                    analysisHTML += `<div class="analysis-item">‚Ä¢ ‚úçÔ∏è Entrada corregida autom√°ticamente (${correctedInput.corrections.length} correcciones)</div>`;
                }
                
                if (result.combined) {
                    analysisHTML += `<div class="analysis-item">‚Ä¢ üß† Procesamiento avanzado: an√°lisis sem√°ntico, detecci√≥n de incompatibilidades y optimizaci√≥n de coherencia</div>`;
                }
                
                analysisHTML += '</div>';
                analysisDiv.innerHTML = analysisHTML;
                
                conversationContext.push(finalInput);
                if (conversationContext.length > 5) conversationContext.shift();
            }

            updateStats();
        }

        function giveFeedback(isPositive) {
            if (lastUsedSources.length === 0) return;
            
            lastUsedSources.forEach(idx => {
                if (trainingData[idx]) {
                    trainingData[idx].useCount++;
                    if (isPositive) {
                        trainingData[idx].successCount++;
                    } else {
                        trainingData[idx].failCount++;
                    }
                }
            });
            
            saveToStorage();
            
            document.getElementById('feedbackSection').innerHTML = `
                <div class="status success">
                    ${isPositive ? '‚úì ¬°Gracias! IA mejorada' : '‚úì Registrado, ajustando pesos'}
                </div>
            `;
            updateStats();
            viewTraining();
        }

        function downloadTraining() {
            const statusDiv = document.getElementById('trainStatus');
            
            if (trainingData.length === 0) {
                statusDiv.innerHTML = '<div class="status error">Sin datos</div>';
                return;
            }

            const dataToExport = {
                version: '3.0',
                exportDate: new Date().toISOString(),
                trainingData: trainingData,
                questionCount: questionCount,
            };

            const dataStr = JSON.stringify(dataToExport, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `ia-ultra-v2-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(url);

            statusDiv.innerHTML = '<div class="status success">‚úì Descargado</div>';
            setTimeout(() => { statusDiv.innerHTML = ''; }, 3000);
        }

        function loadTraining(event) {
            const file = event.target.files[0];
            const statusDiv = document.getElementById('trainStatus');
            
            if (!file) return;

            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (!importedData.trainingData) {
                        throw new Error('Formato inv√°lido');
                    }

                    const loadedCount = importedData.trainingData.length;
                    
                    if (trainingData.length > 0) {
                        if (confirm(`Tienes ${trainingData.length}.\n\nOK=Reemplazar\nCancel=Agregar`)) {
                            trainingData = importedData.trainingData;
                        } else {
                            trainingData = [...trainingData, ...importedData.trainingData];
                        }
                    } else {
                        trainingData = importedData.trainingData;
                    }
                    
                    if (importedData.questionCount) {
                        questionCount = importedData.questionCount;
                    }
                    
                    saveToStorage();
                    
                    statusDiv.innerHTML = `<div class="status success">‚úì ${loadedCount} cargados</div>`;
                    updateStats();
                    viewTraining();
                    
                    setTimeout(() => { statusDiv.innerHTML = ''; }, 3000);
                    
                } catch (error) {
                    statusDiv.innerHTML = `<div class="status error">Error: ${error.message}</div>`;
                }
            };
            
            reader.readAsText(file);
            event.target.value = '';
        }

        function calculateTotalWords() {
            const allWords = new Set();
            trainingData.forEach(item => {
                item.questionWords.forEach(w => allWords.add(w));
                item.answerWords.forEach(w => allWords.add(w));
            });
            return allWords.size;
        }

        function viewTraining() {
            const listDiv = document.getElementById('trainingList');
            
            if (trainingData.length === 0) {
                listDiv.innerHTML = '<div class="status info">Sin entrenamiento</div>';
                return;
            }

            const sortedData = [...trainingData].sort((a, b) => {
                const rateA = a.successCount / (a.successCount + a.failCount || 1);
                const rateB = b.successCount / (b.successCount + b.failCount || 1);
                return rateB - rateA;
            });

            listDiv.innerHTML = sortedData.map(item => {
                const successRate = item.successCount / (item.successCount + item.failCount || 1);
                const rateColor = successRate > 0.7 ? '#4caf50' : successRate > 0.4 ? '#ff9800' : '#f44336';
                
                return `
                    <div class="training-item">
                        <div class="training-content">
                            <strong>Entrada:</strong> ${item.question}<br>
                            <strong>Salida:</strong> ${item.answer}<br>
                            <div style="margin-top: 8px; color: #666; font-size: 0.9em;">
                                <strong>Keywords:</strong> ${item.keywords.slice(0, 6).join(', ')}${item.keywords.length > 6 ? '...' : ''}
                            </div>
                            <div style="margin-top: 8px; display: flex; gap: 15px; font-size: 0.85em; flex-wrap: wrap;">
                                <span><strong>Usos:</strong> ${item.useCount}</span>
                                <span><strong>‚úì:</strong> ${item.successCount}</span>
                                <span><strong>‚úó:</strong> ${item.failCount}</span>
                                <span style="color: ${rateColor};"><strong>Tasa:</strong> ${(successRate * 100).toFixed(0)}%</span>
                            </div>
                        </div>
                        <button class="btn-delete" onclick="deleteTraining('${item.id}')">üóëÔ∏è</button>
                    </div>
                `;
            }).join('');
        }

        function clearAllTraining() {
            if (!confirm('¬øBORRAR TODO?')) return;

            trainingData = [];
            questionCount = 0;
            conversationContext = [];
            lastUsedSources = [];
            
            saveToStorage();
            
            document.getElementById('trainStatus').innerHTML = '<div class="status success">‚úì Limpio</div>';
            updateStats();
            viewTraining();
        }

        function updateStats() {
            document.getElementById('totalTraining').textContent = trainingData.length;
            document.getElementById('totalQuestions').textContent = questionCount;
            document.getElementById('totalWords').textContent = calculateTotalWords();
            
            const size = new Blob([JSON.stringify(trainingData)]).size;
            document.getElementById('dbSize').textContent = (size / 1024).toFixed(2) + ' KB';
        }

        function updateAutoTags() {
            const question = document.getElementById('question').value.trim();
            const answer = document.getElementById('answer').value.trim();
            
            if (!question && !answer) {
                document.getElementById('autoTags').style.display = 'none';
                return;
            }
            
            const keywords = extractKeywords(question + ' ' + answer);
            const uniqueKeywords = [...new Set(keywords)];
            
            if (uniqueKeywords.length > 0) {
                document.getElementById('tagsList').innerHTML = uniqueKeywords.slice(0, 8).map(tag => 
                    `<span>${tag}</span>`
                ).join('') + (uniqueKeywords.length > 8 ? '<span>+</span>' : '');
                document.getElementById('autoTags').style.display = 'block';
            } else {
                document.getElementById('autoTags').style.display = 'none';
            }
        }

        document.getElementById('question').addEventListener('input', updateAutoTags);
        document.getElementById('answer').addEventListener('input', updateAutoTags);

        window.addEventListener('load', () => {
            checkStorageAvailability();
            loadFromStorage();
            updateStats();
            viewTraining();
        });
    </script>
</body>
</html>