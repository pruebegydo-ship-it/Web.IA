<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>IA 3D Aprendizaje AutÃ³nomo</title>
<style>
html,body{
 margin:0;padding:0;overflow:hidden;background:#000;
 touch-action:none;
}

#joy{
 position:absolute;left:20px;bottom:20px;
 width:120px;height:120px;border-radius:50%;
 background:rgba(255,255,255,.25);
 z-index:10;
}
#stick{
 position:absolute;
 width:50px;height:50px;border-radius:50%;
 background:rgba(255,255,255,.8);
 left:35px;top:35px;
 pointer-events:none;
}

#console{
 position:absolute;
 top:60px;left:10px;
 width:340px;height:200px;
 overflow-y:scroll;
 background:rgba(0,0,0,.9);
 color:#0f0;
 font-family:monospace;
 font-size:11px;
 padding:8px;
 border-radius:6px;
 border:1px solid #0f0;
}

#stats{
 position:absolute;
 top:10px;left:10px;
 background:rgba(0,0,0,.9);
 color:#fff;
 font-family:monospace;
 font-size:12px;
 padding:8px 12px;
 border-radius:6px;
 border:1px solid #fff;
 font-weight:bold;
}

#inputContainer{
 position:absolute;
 bottom:20px;left:160px;
 width:320px;
}

#input{
 width:100%;
 background:rgba(0,0,0,.9);
 border:2px solid #0f0;
 border-radius:6px;
 padding:10px;
 color:#0f0;
 font-family:monospace;
 font-size:13px;
}

#input:focus{
 outline:none;
 border-color:#0ff;
}
</style>
</head>
<body>

<div id="stats"></div>
<div id="console"></div>
<div id="inputContainer">
 <input type="text" id="input" placeholder="Escribe Ã³rdenes para la IA..." autocomplete="off">
</div>

<div id="joy"><div id="stick"></div></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

const scene=new THREE.Scene();
scene.fog=new THREE.Fog(0x87ceeb,80,250);

const skyGeo=new THREE.SphereGeometry(450,32,32);
const skyMat=new THREE.ShaderMaterial({
 side:THREE.BackSide,
 uniforms:{
  topColor:{value:new THREE.Color(0x0055ff)},
  middleColor:{value:new THREE.Color(0x4d9fff)},
  bottomColor:{value:new THREE.Color(0xe6f5ff)},
  sunColor:{value:new THREE.Color(0xffffff)},
  sunPosition:{value:new THREE.Vector3(0.3,0.7,0.2)}
 },
 vertexShader:`
  varying vec3 vNormal;
  void main(){
   vNormal=normalize(position);
   gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
  }
 `,
 fragmentShader:`
  uniform vec3 topColor;
  uniform vec3 middleColor;
  uniform vec3 bottomColor;
  uniform vec3 sunColor;
  uniform vec3 sunPosition;
  varying vec3 vNormal;
  void main(){
   float h=normalize(vNormal).y;
   vec3 skyColor;
   if(h>0.0){
    skyColor=mix(middleColor,topColor,pow(h,0.7));
   }else{
    skyColor=mix(middleColor,bottomColor,pow(abs(h),0.5));
   }
   float sun=max(0.0,dot(normalize(vNormal),normalize(sunPosition)));
   sun=pow(sun,150.0);
   skyColor=mix(skyColor,sunColor,sun);
   float glow=pow(max(0.0,dot(normalize(vNormal),normalize(sunPosition))),8.0)*0.3;
   skyColor+=glow*vec3(1.0,0.9,0.7);
   gl_FragColor=vec4(skyColor,1.0);
  }
 `
});
const sky=new THREE.Mesh(skyGeo,skyMat);
scene.add(sky);

const cloudGroup=new THREE.Group();
scene.add(cloudGroup);

function createCloud(x,y,z){
 const cloud=new THREE.Group();
 const cloudMat=new THREE.MeshLambertMaterial({
  color:0xffffff,
  transparent:true,
  opacity:0.85
 });
 
 const mainSize=3+Math.random()*4;
 for(let i=0;i<5+Math.random()*8;i++){
  const sphere=new THREE.Mesh(
   new THREE.SphereGeometry(mainSize*0.3+Math.random()*mainSize*0.5,8,8),
   cloudMat
  );
  sphere.position.set(
   (Math.random()-0.5)*mainSize*1.5,
   (Math.random()-0.5)*mainSize*0.5,
   (Math.random()-0.5)*mainSize*1.5
  );
  cloud.add(sphere);
 }
 
 cloud.position.set(x,y,z);
 cloud.userData.speed=0.02+Math.random()*0.03;
 cloud.userData.drift=(Math.random()-0.5)*0.01;
 return cloud;
}

for(let i=0;i<40;i++){
 const x=(Math.random()-0.5)*300;
 const y=25+Math.random()*35;
 const z=(Math.random()-0.5)*300;
 cloudGroup.add(createCloud(x,y,z));
}

const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
camera.position.set(0,8,15);

const ambientLight=new THREE.AmbientLight(0xffffff,0.7);
scene.add(ambientLight);

const sun=new THREE.DirectionalLight(0xfff8e7,1.3);
sun.position.set(100,120,80);
scene.add(sun);

const hemiLight=new THREE.HemisphereLight(0x87ceeb,0x6b8e23,0.5);
scene.add(hemiLight);

const WORLD_SIZE=40;
const WALL_LIMIT=WORLD_SIZE/2;

const ground=new THREE.Mesh(
 new THREE.PlaneGeometry(WORLD_SIZE,WORLD_SIZE,1,1),
 new THREE.MeshLambertMaterial({
  color:0x3a9e3a,
  flatShading:false
 })
);
ground.rotation.x=-Math.PI/2;
scene.add(ground);

const wallHeight=8;
const wallThick=2;
const wallMat=new THREE.MeshLambertMaterial({
 color:0x8B4513,
 transparent:true,
 opacity:0
});

const wall1=new THREE.Mesh(new THREE.BoxGeometry(WORLD_SIZE+4,wallHeight,wallThick),wallMat);
wall1.position.set(0,wallHeight/2,WALL_LIMIT);
scene.add(wall1);

const wall2=new THREE.Mesh(new THREE.BoxGeometry(WORLD_SIZE+4,wallHeight,wallThick),wallMat);
wall2.position.set(0,wallHeight/2,-WALL_LIMIT);
scene.add(wall2);

const wall3=new THREE.Mesh(new THREE.BoxGeometry(wallThick,wallHeight,WORLD_SIZE+4),wallMat);
wall3.position.set(WALL_LIMIT,wallHeight/2,0);
scene.add(wall3);

const wall4=new THREE.Mesh(new THREE.BoxGeometry(wallThick,wallHeight,WORLD_SIZE+4),wallMat);
wall4.position.set(-WALL_LIMIT,wallHeight/2,0);
scene.add(wall4);

const blocks=[];
function block(x,z,type){
 const colors={damage:0xff3333,win:0x33ff33,neutral:0xaaaaaa};
 const b=new THREE.Mesh(
  new THREE.BoxGeometry(1.5,1.5,1.5),
  new THREE.MeshLambertMaterial({color:colors[type]})
 );
 b.position.set(x,0.75,z);
 b.userData.type=type;
 scene.add(b);
 blocks.push(b);
}

for(let i=0;i<6;i++){
 const x=(Math.random()-0.5)*(WORLD_SIZE-6);
 const z=(Math.random()-0.5)*(WORLD_SIZE-6);
 block(x,z,"damage");
}

for(let i=0;i<3;i++){
 const x=(Math.random()-0.5)*(WORLD_SIZE-6);
 const z=(Math.random()-0.5)*(WORLD_SIZE-6);
 block(x,z,"win");
}

for(let i=0;i<5;i++){
 const x=(Math.random()-0.5)*(WORLD_SIZE-6);
 const z=(Math.random()-0.5)*(WORLD_SIZE-6);
 block(x,z,"neutral");
}

const agent=new THREE.Mesh(
 new THREE.SphereGeometry(0.6,20,20),
 new THREE.MeshLambertMaterial({color:0x00ffff,emissive:0x00aaaa,emissiveIntensity:0.4})
);
agent.position.set(0,0.6,0);
scene.add(agent);

const con=document.getElementById("console");
const stats=document.getElementById("stats");
const inputEl=document.getElementById("input");

function say(t){
 const d=document.createElement("div");
 d.textContent=t;
 con.appendChild(d);
 if(con.children.length>40) con.removeChild(con.children[0]);
 con.scrollTop=con.scrollHeight;
}

let db=null;
const dbName="IABrainDB";
let needsSave=false;
let dbReady=false;

function openDB(){
 return new Promise((resolve,reject)=>{
  const req=indexedDB.open(dbName,1);
  req.onerror=()=>reject(req.error);
  req.onsuccess=()=>resolve(req.result);
  req.onupgradeneeded=(e)=>{
   const database=e.target.result;
   if(!database.objectStoreNames.contains("brain")){
    database.createObjectStore("brain");
   }
  };
 });
}

function saveKnowledge(){
 if(!db || !dbReady) return;
 
 const tx=db.transaction(["brain"],"readwrite");
 const store=tx.objectStore("brain");
 
 const data={
  q:Q,
  stats:{steps,wins,damages,totalReward,episode,EPSILON},
  state:{
   x:state.x,y:state.y,z:state.z,
   vx:state.vx,vy:state.vy,vz:state.vz,
   rx:state.rx,ry:state.ry,rz:state.rz,
   rvx:state.rvx,rvy:state.rvy,rvz:state.rvz
  }
 };
 
 store.put(data,"memory");
 needsSave=false;
}

function loadKnowledge(){
 if(!db) return;
 
 const tx=db.transaction(["brain"],"readonly");
 const store=tx.objectStore("brain");
 const req=store.get("memory");
 
 req.onsuccess=()=>{
  const data=req.result;
  
  if(data){
   if(data.q){
    Object.assign(Q,data.q);
   }
   
   if(data.stats){
    steps=data.stats.steps||0;
    wins=data.stats.wins||0;
    damages=data.stats.damages||0;
    totalReward=data.stats.totalReward||0;
    episode=data.stats.episode||1;
    EPSILON=data.stats.EPSILON||0.5;
   }
   
   if(data.state){
    state.x=data.state.x||0;
    state.y=data.state.y||0.6;
    state.z=data.state.z||0;
    state.vx=data.state.vx||0;
    state.vy=data.state.vy||0;
    state.vz=data.state.vz||0;
    state.rx=data.state.rx||0;
    state.ry=data.state.ry||0;
    state.rz=data.state.rz||0;
    state.rvx=data.state.rvx||0;
    state.rvy=data.state.rvy||0;
    state.rvz=data.state.rvz||0;
    agent.position.set(state.x,state.y,state.z);
   }
  }
  
  dbReady=true;
 };
 
 req.onerror=()=>{
  dbReady=true;
 };
}

const Q={};
const ALPHA=0.15;
const GAMMA=0.9;
let EPSILON=0.6;

let state={
 x:0,y:0.6,z:0,
 vx:0,vy:0,vz:0,
 rx:0,ry:0,rz:0,
 rvx:0,rvy:0,rvz:0
};

let totalReward=0;
let steps=0;
let wins=0;
let damages=0;
let episode=1;
let currentOrder=null;

openDB().then(database=>{
 db=database;
 loadKnowledge();
}).catch(e=>{
 dbReady=true;
});

setInterval(()=>{
 if(dbReady){
  saveKnowledge();
 }
},1000);

inputEl.addEventListener("keydown",e=>{
 if(e.key==="Enter"){
  const cmd=inputEl.value.trim();
  inputEl.value="";
  
  if(!cmd) return;
  
  say("ðŸ‘¤ "+cmd);
  
  const lower=cmd.toLowerCase();
  
  if(lower.includes("ve") || lower.includes("mueve")){
   if(lower.includes("rojo")){
    const red=blocks.find(b=>b.userData.type==="damage");
    if(red){
     currentOrder={type:"goto",target:red,name:"rojo"};
     say("ðŸ¤– Voy al rojo");
    }
   }else if(lower.includes("verde")){
    const green=blocks.find(b=>b.userData.type==="win");
    if(green){
     currentOrder={type:"goto",target:green,name:"verde"};
     say("ðŸ¤– Voy al verde");
    }
   }else if(lower.includes("gris")){
    const gray=blocks.find(b=>b.userData.type==="neutral");
    if(gray){
     currentOrder={type:"goto",target:gray,name:"gris"};
     say("ðŸ¤– Voy al gris");
    }
   }
  }else if(lower.includes("salta")){
   currentOrder={type:"action",action:6};
   say("ðŸ¤– Saltando");
  }else if(lower.includes("gira")){
   currentOrder={type:"action",action:7};
   say("ðŸ¤– Girando");
  }else if(lower.includes("rapido") || lower.includes("rÃ¡pido")){
   currentOrder={type:"speed",mode:"fast"};
   say("ðŸ¤– Velocidad alta");
  }else if(lower.includes("lento")){
   currentOrder={type:"speed",mode:"slow"};
   say("ðŸ¤– Velocidad baja");
  }else if(lower.includes("para") || lower.includes("detente") || lower.includes("stop")){
   currentOrder=null;
   state.vx=0;
   state.vz=0;
   state.rvx=0;
   state.rvy=0;
   state.rvz=0;
   say("ðŸ¤– Detenido");
  }else if(lower.includes("explora")){
   EPSILON=0.8;
   currentOrder=null;
   say("ðŸ¤– Modo exploraciÃ³n");
  }else if(lower.includes("aprende")){
   EPSILON=0.3;
   say("ðŸ¤– Modo aprendizaje");
  }else if(lower.includes("experto")){
   EPSILON=0.05;
   say("ðŸ¤– Modo experto");
  }else{
   say("ðŸ¤– Prueba: ve al rojo, salta, rÃ¡pido, explora");
  }
 }
});

function key(x,y,z,vx,vy,vz,a){
 return Math.round(x)+","+Math.round(y)+","+Math.round(z)+","+
        Math.round(vx*2)+","+Math.round(vy*2)+","+Math.round(vz*2)+","+a;
}

function getQ(x,y,z,vx,vy,vz,a){
 const k=key(x,y,z,vx,vy,vz,a);
 return Q[k]||0;
}

function setQ(x,y,z,vx,vy,vz,a,val){
 const k=key(x,y,z,vx,vy,vz,a);
 Q[k]=val;
 needsSave=true;
}

const GRAVITY=-9.8;
const FRICTION=0.85;
const ANGULAR_FRICTION=0.9;

function checkCollision(nx,ny,nz){
 for(const b of blocks){
  if(b.userData.type==="neutral") continue;
  
  const dx=Math.abs(b.position.x-nx);
  const dy=Math.abs(b.position.y-ny);
  const dz=Math.abs(b.position.z-nz);
  
  if(dx<1.05 && dy<1.05 && dz<1.05){
   return b;
  }
 }
 return null;
}

function reward(s,col){
 let r=-0.02;
 
 if(Math.abs(s.x)>=WALL_LIMIT-1 || Math.abs(s.z)>=WALL_LIMIT-1){
  return -30;
 }
 
 if(s.y<0.3){
  r+=-5;
 }
 
 const speed=Math.sqrt(s.vx*s.vx+s.vz*s.vz);
 if(speed>0.2){
  r+=0.2;
 }
 
 if(col){
  if(col.userData.type==="damage"){
   damages++;
   return -25;
  }
  if(col.userData.type==="win"){
   wins++;
   say("âœ¨ Objetivo logrado");
   currentOrder=null;
   return 40;
  }
 }
 
 if(currentOrder && currentOrder.type==="goto"){
  const dx=currentOrder.target.position.x-s.x;
  const dz=currentOrder.target.position.z-s.z;
  const dist=Math.sqrt(dx*dx+dz*dz);
  if(dist<2){
   r+=3;
  }
 }
 
 return r;
}

function chooseAction(s){
 if(currentOrder){
  if(currentOrder.type==="goto"){
   const dx=currentOrder.target.position.x-s.x;
   const dz=currentOrder.target.position.z-s.z;
   const dist=Math.sqrt(dx*dx+dz*dz);
   
   if(dist<1.5){
    say("ðŸŽ¯ LleguÃ© a "+currentOrder.name);
    currentOrder=null;
   }else{
    if(Math.abs(dx)>Math.abs(dz)){
     return dx>0?0:1;
    }else{
     return dz>0?2:3;
    }
   }
  }else if(currentOrder.type==="action"){
   const a=currentOrder.action;
   currentOrder=null;
   return a;
  }else if(currentOrder.type==="speed"){
   if(currentOrder.mode==="fast"){
    return Math.random()<0.5?0:2;
   }else{
    return Math.random()<0.5?4:5;
   }
  }
 }
 
 if(Math.random()<EPSILON){
  return Math.floor(Math.random()*10);
 }
 
 let best=-Infinity;
 let bestA=0;
 
 for(let a=0;a<10;a++){
  const q=getQ(s.x,s.y,s.z,s.vx,s.vy,s.vz,a);
  if(q>best){
   best=q;
   bestA=a;
  }
 }
 
 return bestA;
}

const actions=[
 {fx:3,fy:0,fz:0,tx:0,ty:0,tz:0},
 {fx:-3,fy:0,fz:0,tx:0,ty:0,tz:0},
 {fx:0,fy:0,fz:3,tx:0,ty:0,tz:0},
 {fx:0,fy:0,fz:-3,tx:0,ty:0,tz:0},
 {fx:1.5,fy:0,fz:0,tx:0,ty:0,tz:0},
 {fx:-1.5,fy:0,fz:0,tx:0,ty:0,tz:0},
 {fx:0,fy:4,fz:0,tx:0,ty:0,tz:0},
 {fx:0,fy:0,fz:0,tx:5,ty:0,tz:0},
 {fx:0,fy:0,fz:0,tx:0,ty:5,tz:0},
 {fx:0,fy:0,fz:0,tx:0,ty:0,tz:5}
];

setInterval(()=>{
 const a=chooseAction(state);
 const act=actions[a];
 
 const dt=0.016;
 
 state.vx+=act.fx*dt;
 state.vy+=(act.fy+GRAVITY)*dt;
 state.vz+=act.fz*dt;
 
 state.rvx+=act.tx*dt;
 state.rvy+=act.ty*dt;
 state.rvz+=act.tz*dt;
 
 const nx=state.x+state.vx*dt;
 const ny=state.y+state.vy*dt;
 const nz=state.z+state.vz*dt;
 
 const collision=checkCollision(nx,ny,nz);
 
 if(collision){
  state.vx*=-0.5;
  state.vz*=-0.5;
 }else{
  state.x=nx;
  state.y=ny;
  state.z=nz;
 }
 
 state.rx+=state.rvx*dt;
 state.ry+=state.rvy*dt;
 state.rz+=state.rvz*dt;
 
 if(state.y<=0.6){
  state.y=0.6;
  state.vy=0;
  state.vx*=FRICTION;
  state.vz*=FRICTION;
 }
 
 state.rvx*=ANGULAR_FRICTION;
 state.rvy*=ANGULAR_FRICTION;
 state.rvz*=ANGULAR_FRICTION;
 
 state.x=Math.max(-WALL_LIMIT+1.5,Math.min(WALL_LIMIT-1.5,state.x));
 state.z=Math.max(-WALL_LIMIT+1.5,Math.min(WALL_LIMIT-1.5,state.z));
 
 const r=reward(state,collision);
 totalReward+=r;
 steps++;
 
 let maxQ=-Infinity;
 for(let na=0;na<10;na++){
  maxQ=Math.max(maxQ,getQ(state.x,state.y,state.z,state.vx,state.vy,state.vz,na));
 }
 
 const oldQ=getQ(state.x,state.y,state.z,state.vx,state.vy,state.vz,a);
 const newQ=oldQ+ALPHA*(r+GAMMA*maxQ-oldQ);
 
 setQ(state.x,state.y,state.z,state.vx,state.vy,state.vz,a,newQ);
 
 agent.position.set(state.x,state.y,state.z);
 agent.rotation.set(state.rx,state.ry,state.rz);
 
 if(r>20){
  EPSILON=Math.max(0.05,EPSILON*0.996);
 }else if(r<-15){
  EPSILON=Math.max(0.05,EPSILON*0.998);
 }
 
 const spd=Math.sqrt(state.vx*state.vx+state.vz*state.vz).toFixed(1);
 stats.innerHTML=`V:${wins} | D:${damages} | R:${totalReward.toFixed(0)} | v:${spd} | KB:${Object.keys(Q).length} | Îµ:${(EPSILON*100).toFixed(0)}%`;
},300);

let jx=0,jy=0,dragJoy=false;
const joy=document.getElementById("joy");
const stick=document.getElementById("stick");

joy.addEventListener("pointerdown",e=>{
 dragJoy=true;
 e.stopPropagation();
});

joy.addEventListener("pointerup",e=>{
 dragJoy=false;
 jx=0;jy=0;
 stick.style.transition="0.2s";
 stick.style.left="35px";stick.style.top="35px";
 setTimeout(()=>stick.style.transition="",200);
 e.stopPropagation();
});

joy.addEventListener("pointermove",e=>{
 if(!dragJoy)return;
 const r=joy.getBoundingClientRect();
 const x=e.clientX-r.left-60;
 const y=e.clientY-r.top-60;
 const d=Math.min(40,Math.hypot(x,y));
 const a=Math.atan2(y,x);
 jx=Math.cos(a)*(d/40);
 jy=Math.sin(a)*(d/40);
 stick.style.left=35+jx*40+"px";
 stick.style.top=35+jy*40+"px";
 e.stopPropagation();
});

let yaw=0,pitch=0,lookDrag=false,lx=0,ly=0;

renderer.domElement.addEventListener("pointerdown",e=>{
 if(!dragJoy && e.clientX>200){
  lookDrag=true;
  lx=e.clientX;
  ly=e.clientY;
 }
});

renderer.domElement.addEventListener("pointermove",e=>{
 if(!lookDrag)return;
 yaw-=(e.clientX-lx)*0.01;
 pitch-=(e.clientY-ly)*0.01;
 pitch=Math.max(-1.5,Math.min(1.5,pitch));
 lx=e.clientX;
 ly=e.clientY;
});

renderer.domElement.addEventListener("pointerup",()=>{
 lookDrag=false;
});

let time=0;
function animate(){
 requestAnimationFrame(animate);
 time+=0.01;

 cloudGroup.children.forEach(cloud=>{
  cloud.position.x+=cloud.userData.speed;
  cloud.position.z+=cloud.userData.drift;
  if(cloud.position.x>200) cloud.position.x=-200;
  if(cloud.position.x<-200) cloud.position.x=200;
 });

 const forward=new THREE.Vector3(
  Math.sin(yaw),
  0,
  Math.cos(yaw)
 );
 const right=new THREE.Vector3(
  Math.cos(yaw),
  0,
  -Math.sin(yaw)
 );

 camera.position.add(forward.multiplyScalar(jy*0.5));
 camera.position.add(right.multiplyScalar(jx*0.5));
 
 camera.position.x=Math.max(-WALL_LIMIT+2,Math.min(WALL_LIMIT-2,camera.position.x));
 camera.position.z=Math.max(-WALL_LIMIT+2,Math.min(WALL_LIMIT-2,camera.position.z));
 camera.position.y=Math.max(2,Math.min(30,camera.position.y));
 
 camera.rotation.set(pitch,yaw,0,"YXZ");

 renderer.render(scene,camera);
}
animate();

onresize=()=>{
 camera.aspect=innerWidth/innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(innerWidth,innerHeight);
};
</script>
</body>
</html>