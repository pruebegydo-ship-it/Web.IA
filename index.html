<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IA Ultra Avanzada con Correcci√≥n Autom√°tica</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header .badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            margin: 5px;
            font-size: 0.9em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }

        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
        }

        .btn-info {
            background: linear-gradient(135deg, #2196F3 0%, #0d8bf2 100%);
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .btn-delete {
            background: #f44336;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
        }

        .btn-delete:hover {
            background: #d32f2f;
            transform: scale(1.05);
        }

        .response-box {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #667eea;
            min-height: 150px;
            margin-top: 15px;
            max-height: 500px;
            overflow-y: auto;
        }

        .training-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
        }

        .training-content {
            flex: 1;
        }

        .training-item strong {
            color: #667eea;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .stat-card .number {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-card .label {
            color: #666;
            margin-top: 5px;
        }

        .status {
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
            font-weight: 600;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }

        .status.warning {
            background: #fff3cd;
            color: #856404;
        }

        .analysis {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid #2196F3;
        }

        .analysis-item {
            margin: 5px 0;
            color: #0d47a1;
        }

        .match-score {
            display: inline-block;
            background: #4caf50;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .combined-badge {
            display: inline-block;
            background: #ff9800;
            color: white;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: bold;
            margin-left: 10px;
        }

        .source-list {
            background: #f0f4f8;
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
            font-size: 0.9em;
        }

        .source-item {
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        .source-weight {
            display: inline-block;
            background: #e3f2fd;
            color: #1976d2;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .auto-tags {
            background: #f0f8ff;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .auto-tags span {
            display: inline-block;
            background: #e1f5fe;
            padding: 3px 8px;
            border-radius: 12px;
            margin: 2px;
            font-size: 0.8em;
        }

        .correction-box {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .correction-box h4 {
            color: #856404;
            margin-bottom: 8px;
        }

        .correction-item {
            background: white;
            padding: 6px 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #ff9800;
        }

        .correction-item .before {
            text-decoration: line-through;
            color: #d32f2f;
        }

        .correction-item .after {
            color: #388e3c;
            font-weight: bold;
        }

        .feedback-btns {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .feedback-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: transform 0.2s;
        }

        .feedback-btn:hover {
            transform: scale(1.05);
        }

        .feedback-good {
            background: #4caf50;
            color: white;
        }

        .feedback-bad {
            background: #f44336;
            color: white;
        }

        #fileInput {
            display: none;
        }

        .generated-response {
            background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
            padding: 18px;
            border-radius: 10px;
            margin: 12px 0;
            border-left: 4px solid #4caf50;
            line-height: 1.8;
            font-size: 1.05em;
        }

        .coherence-badge {
            display: inline-block;
            background: #9c27b0;
            color: white;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: bold;
            margin-left: 10px;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 15px;
            background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .toggle-label {
            font-weight: 600;
            color: #667eea;
            font-size: 1.1em;
        }

        .toggle-description {
            font-size: 0.85em;
            color: #666;
            margin-top: 5px;
        }

        .thinking-indicator {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #9c27b0;
            animation: pulse 2s infinite;
            max-height: 400px;
            overflow-y: auto;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .thinking-step {
            margin: 8px 0;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            font-size: 0.9em;
            color: #4a148c;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .btn-group {
                grid-template-columns: 1fr;
            }

            .training-item {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† IA Ultra Avanzada</h1>
            <p>Con Correcci√≥n Ortogr√°fica y An√°lisis Vocal Autom√°tico</p>
            <div>
                <span class="badge">‚úçÔ∏è Auto-Correcci√≥n</span>
                <span class="badge">üîÄ IA Combinada</span>
                <span class="badge">üéµ An√°lisis Vocal</span>
                <span class="badge">üéØ Precisi√≥n Mejorada</span>
                <span class="badge">üíæ Auto-Guardado</span>
                <span class="badge">üß† Pensamiento Profundo</span>
                <span class="badge">üìù L√≥gica Abecedario</span>
            </div>
        </div>

        <div class="main-content">
            <div class="section">
                <h2>üìö Entrenar IA</h2>
                <div class="input-group">
                    <label for="question">Pregunta / Entrada:</label>
                    <textarea id="question" placeholder="Escribe aqu√≠... (La IA corregir√° autom√°ticamente)"></textarea>
                </div>
                <div class="input-group">
                    <label for="answer">Respuesta / Salida:</label>
                    <textarea id="answer" placeholder="Escribe la respuesta... (Se corregir√° al guardar)"></textarea>
                </div>
                <div id="corrections" class="correction-box" style="display:none;"></div>
                <div id="autoTags" class="auto-tags" style="display:none;">
                    <strong>Palabras clave:</strong> <span id="tagsList"></span>
                </div>
                <button class="btn" onclick="trainAI()">‚úÖ Entrenar IA (con correcci√≥n)</button>
                <button class="btn btn-secondary" onclick="viewTraining()">Ver Entrenamiento</button>
                
                <div class="btn-group">
                    <button class="btn btn-success" onclick="downloadTraining()">üì• Descargar</button>
                    <button class="btn btn-info" onclick="document.getElementById('fileInput').click()">üì§ Cargar</button>
                </div>
                <input type="file" id="fileInput" accept=".json" onchange="loadTraining(event)">
                
                <button class="btn btn-danger" onclick="clearAllTraining()">üóëÔ∏è Borrar Todo</button>
                <div id="trainStatus"></div>
            </div>

            <div class="section">
                <h2>üí¨ Consultar IA</h2>
                
                <div class="toggle-container">
                    <label class="toggle-switch">
                        <input type="checkbox" id="deepThinkingToggle" onchange="toggleDeepThinking()">
                        <span class="slider"></span>
                    </label>
                    <div>
                        <div class="toggle-label">üß† Modo Pensamiento Profundo</div>
                        <div class="toggle-description">An√°lisis detallado y respuestas m√°s precisas</div>
                    </div>
                    <div style="margin-left: auto; display: flex; flex-direction: column; align-items: flex-end;">
                        <label for="thinkingTime" style="font-size: 0.9em; color: #666; text-align: right;">Tiempo (s):</label>
                        <input type="number" id="thinkingTime" placeholder="3" min="1" max="30" value="" style="width: 60px; text-align: center;">
                    </div>
                </div>

                <div class="input-group">
                    <label for="userQuestion">Pregunta:</label>
                    <textarea id="userQuestion" placeholder="Escribe tu pregunta... La IA generar√° respuestas inteligentes"></textarea>
                </div>
                <button class="btn" onclick="askAI()">üöÄ Consultar</button>
                
                <div id="thinkingProcess" style="display:none;"></div>
                
                <div class="response-box" id="aiResponse">
                    La IA analizar√° profundamente tu pregunta y generar√° una respuesta combinada con correcci√≥n autom√°tica...
                </div>
                <div id="feedbackSection"></div>
                <div id="analysis"></div>
            </div>

            <div class="section" style="grid-column: 1 / -1;">
                <h2>üìä Estad√≠sticas</h2>
                <div class="stats">
                    <div class="stat-card">
                        <div class="number" id="totalTraining">0</div>
                        <div class="label">Entrenamientos</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="totalWords">0</div>
                        <div class="label">Palabras √önicas</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="totalQuestions">0</div>
                        <div class="label">Consultas</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="dbSize">0 KB</div>
                        <div class="label">Tama√±o BD</div>
                    </div>
                </div>
            </div>

            <div class="section" style="grid-column: 1 / -1;">
                <h2>üìù Base de Conocimiento</h2>
                <div id="trainingList"></div>
            </div>
        </div>
    </div>

    <script>
        let trainingData = [];
        let questionCount = 0;
        let conversationContext = [];
        let lastUsedSources = [];
        let deepThinkingMode = false;

        const synonyms = {
            'hola': ['saludos', 'buenas', 'hey', 'alo', 'que tal'],
            'adios': ['chao', 'hasta luego', 'nos vemos', 'bye'],
            'gracias': ['muchas gracias', 'agradecido', 'thanks'],
            'ayuda': ['ayudar', 'asistencia', 'soporte', 'auxilio'],
            'como': ['de que manera', 'de que forma'],
            'que': ['cual', 'cuales'],
            'hacer': ['realizar', 'ejecutar', 'crear'],
            'bueno': ['bien', 'excelente', 'genial', 'perfecto'],
            'malo': ['mal', 'pesimo', 'terrible'],
            'programar': ['programacion', 'codificar', 'codigo', 'desarrollar'],
            'javascript': ['js', 'ecmascript'],
            'python': ['py'],
            'aprender': ['estudiar', 'ensenar', 'educacion'],
            'sabes': ['conoces', 'sabes sobre', 'conocimiento'],
            'saber': ['conocer', 'informacion', 'datos']
        };

        // Nuevos diccionarios para clasificar tipos de entrada
        const greetings = ['hola', 'buenas', 'hey', 'alo', 'que tal', 'saludos', 'buen dia', 'buenas tardes', 'buenas noches'];
        const farewells = ['adios', 'chao', 'hasta luego', 'nos vemos', 'bye'];
        const insults = ['idiota', 'tonto', 'imbecil', 'estupido', 'pendejo', 'bro mal', 'insulto', 'malo'];
        const thanks = ['gracias', 'thank you', 'agradecido'];

        const spellingCorrections = {
            'q': 'que', 'xq': 'porque', 'pq': 'porque', 'xk': 'porque',
            'tb': 'tambi√©n', 'tmb': 'tambi√©n', 'bn': 'bien',
            'd': 'de', 'k': 'que', 'x': 'por', 'pa': 'para',
            'porfa': 'por favor', 'porfavor': 'por favor',
            'hola': 'hola', 'ola': 'hola',
            'aver': 'a ver', 'aber': 'a ver',
            'aslo': 'hazlo', 'ase': 'hace', 'ahy': 'ah√≠',
            'q': 'qu√©', 'komo': 'como', 'kien': 'quien',
            'xfa': 'por favor', 'porq': 'porque',
            'entiendes': 'entiendes', 'bn': 'bien',
            'bro': 'hermano', 'wey': 'amigo'
        };

        const accentCorrections = {
            'como': 'c√≥mo', 'que': 'qu√©', 'cual': 'cu√°l', 'donde': 'd√≥nde',
            'cuando': 'cu√°ndo', 'quien': 'qui√©n', 'cuanto': 'cu√°nto',
            'mas': 'm√°s', 'si': 's√≠', 'tu': 't√∫', 'mi': 'm√≠',
            'te': 't√©', 'el': '√©l', 'solo': 's√≥lo',
            'esta': 'est√°', 'estas': 'est√°s', 'este': 'est√©',
            'razon': 'raz√≥n', 'acion': 'acci√≥n', 'informacion': 'informaci√≥n',
            'codigo': 'c√≥digo', 'tambien': 'tambi√©n', 'ahi': 'ah√≠',
            'dia': 'd√≠a', 'despues': 'despu√©s', 'facil': 'f√°cil',
            'dificil': 'dif√≠cil', 'util': '√∫til', 'semantica': 'sem√°ntica'
        };

        // Nueva funci√≥n para clasificar el tipo de entrada
        function classifyInput(text) {
            const normalized = normalizeText(text);
            const words = normalized.split(/\s+/);

            // Verificar si es pregunta
            if (text.includes('?') || words.some(w => w.startsWith('que') || w.startsWith('como') || w.startsWith('cuando') || w.startsWith('donde') || w.startsWith('cual'))) {
                return { type: 'question', length: words.length };
            }

            // Saludo
            if (greetings.some(g => words.includes(g) || normalized.includes(g))) {
                return { type: 'greeting', length: 1 }; // Corto por defecto
            }

            // Despedida
            if (farewells.some(f => words.includes(f) || normalized.includes(f))) {
                return { type: 'farewell', length: 1 };
            }

            // Insulto
            if (insults.some(i => words.includes(i) || normalized.includes(i))) {
                return { type: 'insult', length: 2 }; // Corto y witty
            }

            // Agradecimiento
            if (thanks.some(t => words.includes(t) || normalized.includes(t))) {
                return { type: 'thanks', length: 1 };
            }

            // Por defecto, tratar como pregunta o statement
            return { type: 'statement', length: words.length };
        }

        function toggleDeepThinking() {
            deepThinkingMode = document.getElementById('deepThinkingToggle').checked;
            saveToStorage();
        }

        // Mejorada: An√°lisis de abecedario completo (letras + l√≥gica Grok-like)
        function analyzeAlphabetPattern(text) {
            const alphabet = 'abcdefghijklmnopqrstuvwxyz√°√©√≠√≥√∫√±';
            const normalized = text.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
            let letterCount = {};
            let pattern = '';

            for (let char of normalized) {
                if (alphabet.includes(char)) {
                    pattern += char;
                    letterCount[char] = (letterCount[char] || 0) + 1;
                }
            }

            const totalLetters = Object.values(letterCount).reduce((a, b) => a + b, 0);
            const letterRatio = totalLetters / normalized.length || 0;

            // L√≥gica simple Grok-like: Detectar patrones repetidos o raros
            const repeated = Object.entries(letterCount).filter(([k, v]) => v > 3).map(([k]) => k).join('');
            const rare = Object.entries(letterCount).filter(([k, v]) => v === 1).length;

            return {
                letterPattern: pattern,
                letterCount,
                totalLetters,
                letterRatio,
                repeatedLetters: repeated,
                rareLetters: rare,
                logicalInsight: rare > 5 ? 'Texto creativo con vocabulario variado' : 'Estilo directo y repetitivo'
            };
        }

        // Generaci√≥n de variaciones con abecedario completo (mutaciones l√≥gicas)
        function generateAlphabetVariations(word) {
            const variations = [word];
            const alphabetMap = {}; // Mapa simple para swaps l√≥gicos (e.g., b->v para errores comunes)
            alphabetMap['b'] = ['v', 'p']; // Ejemplos de confusiones fon√©ticas
            alphabetMap['c'] = ['k', 's'];
            alphabetMap['g'] = ['j'];
            // ... agregar m√°s si se quiere, pero mantener simple

            for (let i = 0; i < word.length; i++) {
                const char = word[i].toLowerCase();
                if (alphabetMap[char]) {
                    alphabetMap[char].forEach(variant => {
                        const newWord = word.substring(0, i) + variant + word.substring(i + 1);
                        variations.push(newWord);
                    });
                }
            }

            return variations;
        }

        // Comparaci√≥n mejorada con abecedario
        function compareAlphabetPatterns(pattern1, pattern2) {
            const p1 = analyzeAlphabetPattern(pattern1);
            const p2 = analyzeAlphabetPattern(pattern2);

            let score = 0;

            // Coincidencias de letras comunes
            const commonLetters = Object.keys(p1.letterCount).filter(l => p2.letterCount[l]);
            score += commonLetters.length * 4;

            // Patrones repetidos similares
            if (p1.repeatedLetters.includes(p2.repeatedLetters[0])) score += 15;

            // Ratio similar
            const ratioDiff = Math.abs(p1.letterRatio - p2.letterRatio);
            score += (1 - ratioDiff) * 20;

            // Insights l√≥gicos coincidentes (simple)
            if (p1.logicalInsight.includes(p2.logicalInsight.split(' ')[0])) score += 10;

            return score;
        }

        // Funci√≥n mejorada para steps de pensamiento profundo (m√°s l√≥gica, abecedario, Grok-like)
        function generateDynamicStep(userInput, elapsedTime, totalTime, matches, inputClass) {
            const progress = (elapsedTime / totalTime) * 100;
            const depth = Math.floor(progress / 20);
            const dbSize = trainingData.length;
            const alphaAnalysis = analyzeAlphabetPattern(userInput);
            const userType = inputClass.type;
            const userLen = inputClass.length;

            let step = '';
            if (elapsedTime < 1000) {
                step = `Clasificando entrada: "${userType}" (longitud: ${userLen} palabras). Iniciando tokenizaci√≥n abecedario.`;
            } else if (elapsedTime < 2000) {
                step = `An√°lisis alfab√©tico: Letras repetidas "${alphaAnalysis.repeatedLetters}", raras: ${alphaAnalysis.rareLetters}. Insight: ${alphaAnalysis.logicalInsight}.`;
            } else if (elapsedTime < 3000) {
                step = `Buscando en ${dbSize} entradas. Matches iniciales: ${matches.length}. Ajustando por tipo ${userType}.`;
            } else if (elapsedTime < 4000) {
                step = `L√≥gica Grok: ¬ø${userType === 'question' ? 'Respuesta detallada?' : userType === 'insult' ? 'Contraataque witty?' : 'Respuesta amigable?'}. Cruzando contextos.`;
            } else if (elapsedTime < 5000) {
                step = `Profundizando abecedario: Generando variaciones l√≥gicas para keywords. Ej: "${generateAlphabetVariations(extractKeywords(userInput)[0] || 'base')[1]}".`;
            } else if (elapsedTime < 6000) {
                step = `Evaluando longitud respuesta: ${userLen < 5 ? 'Corta' : 'Larga'}. Integrando sin√≥nimos y patrones fon√©ticos.`;
            } else if (elapsedTime < 7000) {
                step = `Cadena l√≥gica: Conectando matches con ${conversationContext.length} contextos previos. Detectando contradicciones.`;
            } else if (elapsedTime < 8000) {
                step = `An√°lisis de sentido: ¬øCoherente con entrenamiento? Ajustando pesos (confianza: ${Math.round(Math.random()*50 + 50)}%).`;
            } else {
                step = `Sintetizando como Grok: Respuesta adaptada a ${userType}, con humor si insulto. Confianza: ${Math.min(95 + depth*5, 100)}%.`;
            }

            return step;
        }

        function showThinkingProcess(userInput, totalTime, matches, inputClass) {
            const thinkingDiv = document.getElementById('thinkingProcess');
            if (!deepThinkingMode) {
                thinkingDiv.style.display = 'none';
                return;
            }

            let html = '<div class="thinking-indicator"><strong>üß† Pensando Profundamente (Grok-Style)...</strong><div id="dynamicSteps"></div>';
            html += '<div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>';
            html += '<div class="progress-text" id="progressText">Iniciando an√°lisis l√≥gico...</div>';
            html += '</div>';
            thinkingDiv.innerHTML = html;
            thinkingDiv.style.display = 'block';

            const dynamicSteps = document.getElementById('dynamicSteps');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            let elapsed = 0;
            let stepCount = 0;

            const interval = setInterval(() => {
                elapsed += 500;
                const progress = Math.min((elapsed / totalTime) * 100, 100);
                progressFill.style.width = progress + '%';

                const remaining = Math.max(0, Math.ceil((totalTime - elapsed) / 1000));
                progressText.textContent = `${progress.toFixed(0)}% - ${remaining}s restantes | Tipo: ${inputClass.type}`;

                if (elapsed % 1500 < 500) { // M√°s frecuente para m√°s profundidad
                    const newStep = generateDynamicStep(userInput, elapsed, totalTime, matches, inputClass);
                    const stepEl = document.createElement('div');
                    stepEl.className = 'thinking-step';
                    stepEl.textContent = `‚Ä¢ ${newStep}`;
                    dynamicSteps.appendChild(stepEl);
                    stepCount++;
                }

                if (progress >= 100) {
                    clearInterval(interval);
                    progressText.textContent = '¬°L√≥gica completa! Generando respuesta adaptada...';
                    dynamicSteps.innerHTML += `<div class="thinking-step">‚Ä¢ Respuesta final: Sensata, l√≥gica y personalizada.</div>`;
                }
            }, 500);

            setTimeout(() => {
                thinkingDiv.style.display = 'none';
            }, totalTime + 1000);
        }

        function calculateSimilarity(text1, text2) {
            const tokens1 = tokenize(text1);
            const tokens2 = tokenize(text2);
            
            const set1 = new Set(tokens1.words);
            const set2 = new Set(tokens2.words);
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            const jaccard = union.size === 0 ? 0 : intersection.size / union.size;
            
            const levSim = levenshtein(tokens1.normalized, tokens2.normalized);
            
            const stemSet1 = new Set(tokens1.stems);
            const stemSet2 = new Set(tokens2.stems);
            const stemIntersection = new Set([...stemSet1].filter(x => stemSet2.has(x)));
            const stemUnion = new Set([...stemSet1, ...stemSet2]);
            const stemSim = stemUnion.size === 0 ? 0 : stemIntersection.size / stemUnion.size;
            
            const bigramSet1 = new Set(tokens1.bigrams);
            const bigramSet2 = new Set(tokens2.bigrams);
            const bigramIntersection = new Set([...bigramSet1].filter(x => bigramSet2.has(x)));
            const bigramUnion = new Set([...bigramSet1, ...bigramSet2]);
            const bigramSim = bigramUnion.size === 0 ? 0 : bigramIntersection.size / bigramUnion.size;
            
            let containsSim = 0;
            if (tokens1.normalized.includes(tokens2.normalized) || tokens2.normalized.includes(tokens1.normalized)) {
                const shorter = Math.min(tokens1.normalized.length, tokens2.normalized.length);
                const longer = Math.max(tokens1.normalized.length, tokens2.normalized.length);
                containsSim = shorter / longer;
            }
            
            const vocalSim = compareVocalPatterns(text1, text2) / 100;
            const alphaSim = compareAlphabetPatterns(text1, text2) / 100; // Nueva: abecedario
            
            return (jaccard * 0.20 + levSim * 0.20 + stemSim * 0.15 + bigramSim * 0.15 + containsSim * 0.10 + vocalSim * 0.10 + alphaSim * 0.10) * 100;
        }

        // Mejorada: Considera tipo de input para longitud
        function determineResponseLength(userInput, topMatches, inputClass) {
            const inputLength = inputClass.length || userInput.split(/\s+/).length;
            const userType = inputClass.type;
            
            // Ajustes por tipo
            if (userType === 'greeting' || userType === 'thanks' || userType === 'farewell') {
                return 'short';
            }
            if (userType === 'insult') {
                return 'short'; // Witty y breve
            }
            
            const isSimpleQuery = /^(que es|quien es|cual es|donde esta|cuando|como se)/i.test(userInput);
            
            const hasDirectAnswer = topMatches.length > 0 && topMatches[0].score > 85;
            
            if (isSimpleQuery || inputLength < 5) {
                return 'short';
            }
            
            if (hasDirectAnswer && topMatches[0].item.answer.split(/\s+/).length < 30) {
                return 'short';
            }
            
            if (inputLength > 15 || userInput.includes('explica') || userInput.includes('detalla')) {
                return 'long';
            }
            
            return 'medium';
        }

        // En selectBestSentences, agregar ajuste por tipo (e.g., para insultos, priorizar witty)
        function selectBestSentences(sentences, userInput, targetLength, inputClass) {
            let maxSentences;
            if (targetLength === 'short') maxSentences = 1; // M√°s corto para greetings/insults
            else if (targetLength === 'medium') maxSentences = 2;
            else maxSentences = 4;

            // Ajuste por tipo: Para insultos, boost witty (simple keyword)
            sentences.forEach(sent => {
                sent.semanticScore = calculateSemanticRelevance(userInput, sent.text);
                let typeBoost = 0;
                if (inputClass.type === 'insult' && sent.text.toLowerCase().includes('humor') || sent.text.toLowerCase().includes('witty') || sent.text.toLowerCase().includes('gracioso')) {
                    typeBoost = 20;
                } else if (inputClass.type === 'greeting' && sent.text.toLowerCase().includes('amigable')) {
                    typeBoost = 15;
                }
                sent.finalScore = (sent.weight * 0.3) + (sent.semanticScore * 0.6) + typeBoost * 0.1;
            });

            sentences.sort((a, b) => b.finalScore - a.finalScore);

            const selected = [];
            const usedConcepts = new Set();

            for (let sent of sentences) {
                if (selected.length >= maxSentences) break;

                const sentWords = new Set(tokenize(sent.text).words);
                const isDuplicate = [...usedConcepts].filter(w => sentWords.has(w)).length > 2;

                if (!isDuplicate || selected.length === 0) {
                    selected.push(sent);
                    sentWords.forEach(w => usedConcepts.add(w));
                }
            }

            return selected;
        }

        // En generateCombinedResponse: Pasar inputClass, ajustar connectors por tipo
        function generateCombinedResponse(userInput, matches, inputClass) {
            if (matches.length === 0) return null;
            
            const timeInput = document.getElementById('thinkingTime').value;
            const totalTime = timeInput && !isNaN(timeInput) ? parseInt(timeInput) * 1000 : 4000; // Aumentado para m√°s profundidad
            
            if (deepThinkingMode) {
                showThinkingProcess(userInput, totalTime, matches, inputClass);
            }

            return new Promise((resolve) => {
                setTimeout(() => {
                    const minScore = deepThinkingMode ? 25 : 20; // M√°s permisivo
                    const topMatches = matches.slice(0, 8).filter(m => m.score > minScore); // M√°s matches para variedad
                    
                    if (topMatches.length === 0) {
                        // Fallback por tipo
                        let fallback = '';
                        switch (inputClass.type) {
                            case 'greeting': fallback = '¬°Hola! ¬øEn qu√© puedo ayudarte hoy?'; break;
                            case 'farewell': fallback = '¬°Hasta luego! Cu√≠date.'; break;
                            case 'insult': fallback = '¬°Oye, bro! Si eso es lo mejor que tienes, practica m√°s. üòè ¬øQu√© tal si charlamos de verdad?'; break;
                            case 'thanks': fallback = '¬°De nada! Siempre un placer.'; break;
                            default: fallback = 'Interesante... Cu√©ntame m√°s para entender mejor.';
                        }
                        resolve({
                            response: fallback,
                            combined: false,
                            sources: [],
                            confidence: 70,
                            coherence: 90,
                            inputType: inputClass.type
                        });
                        return;
                    }
                    
                    const responseLength = determineResponseLength(userInput, topMatches, inputClass);
                    
                    if (topMatches.length === 1 && topMatches[0].score > 90) {
                        const corrected = fullCorrection(topMatches[0].item.answer);
                        resolve({
                            response: corrected.text,
                            combined: false,
                            sources: [topMatches[0]],
                            confidence: topMatches[0].score,
                            coherence: 100,
                            inputType: inputClass.type
                        });
                        return;
                    }
                    
                    const weightedSources = topMatches.map(match => {
                        const successRate = match.item.successCount / 
                            (match.item.successCount + match.item.failCount || 1);
                        const weight = (match.score * 0.7) + (successRate * 100 * 0.3);
                        
                        return { ...match, weight, successRate };
                    });
                    
                    weightedSources.sort((a, b) => b.weight - a.weight);
                    
                    const sentences = [];
                    weightedSources.forEach(source => {
                        const answerSentences = source.item.answer
                            .split(/[.!?]+/)
                            .map(s => s.trim())
                            .filter(s => s.length > 5 && s.split(/\s+/).length >= 1); // M√°s flexible para cortos
                        
                        answerSentences.forEach(sentence => {
                            const relevance = calculateSemanticRelevance(userInput, sentence);
                            
                            sentences.push({
                                text: sentence,
                                weight: source.weight,
                                source: source,
                                relevance: relevance
                            });
                        });
                    });
                    
                    const uniqueSentences = [];
                    sentences.forEach(sent => {
                        const isDuplicate = uniqueSentences.some(unique => 
                            calculateSimilarity(sent.text, unique.text) > 85
                        );
                        if (!isDuplicate && sent.text.length > 5) {
                            uniqueSentences.push(sent);
                        }
                    });
                    
                    const selectedSentences = selectBestSentences(uniqueSentences, userInput, responseLength, inputClass);
                    
                    if (selectedSentences.length === 0) {
                        resolve(null);
                        return;
                    }
                    
                    let combinedResponse = '';
                    selectedSentences.forEach((sent, idx) => {
                        let text = sent.text;
                        if (idx === 0) {
                            text = text.charAt(0).toUpperCase() + text.slice(1);
                        } else {
                            // Connectors adaptados por tipo
                            let connectors;
                            if (inputClass.type === 'insult') {
                                connectors = ['. Pero espera, ', '. Jaja, ', '. En serio, ', '. Vamos, '];
                            } else if (inputClass.type === 'greeting') {
                                connectors = ['. Por cierto, ', '. Y t√∫, ', '. Bien, '];
                            } else {
                                connectors = ['. Adem√°s, ', '. Tambi√©n, ', '. En relaci√≥n, ', '. Por lo tanto, '];
                            }
                            const connector = connectors[Math.floor(Math.random() * connectors.length)];
                            text = connector + text.charAt(0).toLowerCase() + text.slice(1);
                        }
                        combinedResponse += text + '. ';
                    });
                    
                    const finalCorrected = fullCorrection(combinedResponse.trim());
                    
                    const totalWeight = selectedSentences.reduce((sum, s) => sum + s.finalScore, 0);
                    const avgConfidence = Math.min((totalWeight / selectedSentences.length) * 1.2, 100);
                    
                    let totalCoherence = 0;
                    for (let i = 1; i < selectedSentences.length; i++) {
                        const sim = calculateSimilarity(selectedSentences[i-1].text, selectedSentences[i].text);
                        totalCoherence += Math.min(sim * 2, 100);
                    }
                    const avgCoherence = selectedSentences.length > 1 ? totalCoherence / (selectedSentences.length - 1) : 100;
                    
                    resolve({
                        response: finalCorrected.text,
                        combined: topMatches.length > 1,
                        sources: weightedSources.slice(0, selectedSentences.length),
                        confidence: avgConfidence,
                        coherence: avgCoherence,
                        inputType: inputClass.type
                    });
                }, totalTime);
            });
        }

        // En askAI: Clasificar input
        async function askAI() {
            const userInput = document.getElementById('userQuestion').value.trim();
            const responseDiv = document.getElementById('aiResponse');
            const analysisDiv = document.getElementById('analysis');
            const feedbackDiv = document.getElementById('feedbackSection');

            if (!userInput) {
                responseDiv.innerHTML = '<div class="status error">Escribe algo</div>';
                return;
            }

            questionCount++;
            saveToStorage();

            if (trainingData.length === 0) {
                responseDiv.innerHTML = '<div class="status info">‚ö†Ô∏è Entrena la IA primero</div>';
                return;
            }

            const correctedInput = fullCorrection(userInput);
            const finalInput = correctedInput.text;
            const inputClass = classifyInput(finalInput); // Nueva clasificaci√≥n

            const matches = findMatches(finalInput);

            if (matches.length === 0 || matches[0].score < 15) {
                // Usar fallback en generate, pero aqu√≠ mostrar
                let fallbackMsg = `ü§î No encontr√© info espec√≠fica para "${inputClass.type}". `;
                if (inputClass.type === 'greeting') fallbackMsg += '¬°Hola, bro! ¬øQu√© onda?';
                else if (inputClass.type === 'insult') fallbackMsg += '¬°Uy, qu√© fuerte! Pero soy IA, no me afecta. ¬øQuieres charlar de verdad?';
                else fallbackMsg += 'Entrena m√°s datos relacionados.';
                responseDiv.innerHTML = `<div class="status info">${fallbackMsg}</div>`;
                analysisDiv.innerHTML = '';
                feedbackDiv.innerHTML = '';
                lastUsedSources = [];
            } else {
                const result = await generateCombinedResponse(finalInput, matches, inputClass);
                
                if (!result) {
                    responseDiv.innerHTML = '<div class="status info">ü§î No puedo generar una respuesta confiable con los datos actuales.</div>';
                    return;
                }
                
                lastUsedSources = result.sources.map(s => s.index);
                
                let html = `
                    <div style="color: #155724;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap;">
                            <strong style="font-size: 1.1em;">ü§ñ Respuesta IA (${result.inputType}):</strong>
                            <div>
                                <span class="match-score">${result.confidence.toFixed(0)}% confianza</span>
                                ${result.combined ? '<span class="combined-badge">üîÄ COMBINADA</span>' : ''}
                                <span class="coherence-badge">üìù ${result.coherence.toFixed(0)}% coherencia</span>
                            </div>
                        </div>
                        <div class="generated-response">
                            ${result.response}
                        </div>
                `;
                
                if (result.sources.length > 0 && deepThinkingMode) {
                    html += '<div class="source-list"><strong>üìö Fuentes utilizadas:</strong>';
                    result.sources.forEach((source, idx) => {
                        html += `
                            <div class="source-item">
                                <span class="source-weight">#${idx + 1} ${source.weight.toFixed(0)}pts</span>
                                "${source.item.question}"
                            </div>
                        `;
                    });
                    html += '</div>';
                }
                
                html += '</div>';
                responseDiv.innerHTML = html;
                
                feedbackDiv.innerHTML = `
                    <div class="feedback-btns">
                        <button class="feedback-btn feedback-good" onclick="giveFeedback(true)">
                            üëç √ötil
                        </button>
                        <button class="feedback-btn feedback-bad" onclick="giveFeedback(false)">
                            üëé Incorrecta
                        </button>
                    </div>
                `;
                
                let analysisHTML = '<div class="analysis">';
                analysisHTML += '<strong>üîç An√°lisis:</strong><br>';
                analysisHTML += `<div class="analysis-item">‚Ä¢ Tipo detectado: ${result.inputType}</div>`;
                analysisHTML += `<div class="analysis-item">‚Ä¢ ${matches.length} fuentes encontradas</div>`;
                analysisHTML += `<div class="analysis-item">‚Ä¢ ${result.sources.length} fuentes utilizadas</div>`;
                analysisHTML += `<div class="analysis-item">‚Ä¢ Coherencia: ${result.coherence.toFixed(0)}%</div>`;
                if (deepThinkingMode) {
                    analysisHTML += `<div class="analysis-item">‚Ä¢ Modo pensamiento profundo (con abecedario) activado</div>`;
                }
                
                if (correctedInput.corrections.length > 0) {
                    analysisHTML += `<div class="analysis-item">‚Ä¢ Pregunta corregida autom√°ticamente</div>`;
                }
                
                analysisHTML += '</div>';
                analysisDiv.innerHTML = analysisHTML;
                
                conversationContext.push(finalInput);
                if (conversationContext.length > 5) conversationContext.shift();
            }

            updateStats();
        }

        function trainAI() {
            const question = document.getElementById('question').value.trim();
            const answer = document.getElementById('answer').value.trim();
            const statusDiv = document.getElementById('trainStatus');

            if (!question || !answer) {
                statusDiv.innerHTML = '<div class="status error">Completa ambos campos</div>';
                return;
            }

            const qCorrected = fullCorrection(question);
            const aCorrected = fullCorrection(answer);
            
            const allCorrections = [...qCorrected.corrections, ...aCorrected.corrections];
            showCorrections(allCorrections);
            
            const correctedQuestion = qCorrected.text;
            const correctedAnswer = aCorrected.text;

            const { words: qWords, stems: qStems, bigrams: qBigrams, trigrams: qTrigrams, vocalPattern: qVocal } = tokenize(correctedQuestion);
            const { words: aWords, stems: aStems, bigrams: aBigrams, trigrams: aTrigrams, vocalPattern: aVocal } = tokenize(correctedAnswer);
            const keywords = extractKeywords(correctedQuestion + ' ' + correctedAnswer);
            
            // Nueva: Clasificar y guardar tipo para entrenamiento
            const qClass = classifyInput(correctedQuestion);
            
            trainingData.push({
                id: Date.now() + Math.random(),
                question: correctedQuestion,
                answer: correctedAnswer,
                inputType: qClass.type, // Nuevo
                questionNorm: normalizeText(correctedQuestion),
                answerNorm: normalizeText(correctedAnswer),
                questionWords: qWords,
                answerWords: aWords,
                questionStems: qStems,
                answerStems: aStems,
                questionBigrams: qBigrams,
                answerBigrams: aBigrams,
                questionTrigrams: qTrigrams,
                answerTrigrams: aTrigrams,
                questionVocalPattern: qVocal,
                answerVocalPattern: aVocal,
                questionAlphabetPattern: analyzeAlphabetPattern(correctedQuestion), // Nuevo
                keywords,
                successCount: 0,
                failCount: 0,
                useCount: 0,
                timestamp: new Date().toISOString()
            });

            saveToStorage();

            statusDiv.innerHTML = `<div class="status success">‚úì Entrenado y guardado${allCorrections.length > 0 ? ' con correcciones' : ''} (Tipo: ${qClass.type})</div>`;
            document.getElementById('question').value = '';
            document.getElementById('answer').value = '';
            document.getElementById('autoTags').style.display = 'none';
            
            setTimeout(() => {
                document.getElementById('corrections').style.display = 'none';
            }, 5000);
            
            updateStats();
            viewTraining();
        }

        // Actualizar viewTraining para mostrar tipo
        function viewTraining() {
            const listDiv = document.getElementById('trainingList');
            
            if (trainingData.length === 0) {
                listDiv.innerHTML = '<div class="status info">Sin entrenamiento</div>';
                return;
            }

            const sortedData = [...trainingData].sort((a, b) => {
                const rateA = a.successCount / (a.successCount + a.failCount || 1);
                const rateB = b.successCount / (b.successCount + b.failCount || 1);
                return rateB - rateA;
            });

            listDiv.innerHTML = sortedData.map(item => {
                const successRate = item.successCount / (item.successCount + item.failCount || 1);
                const rateColor = successRate > 0.7 ? '#4caf50' : successRate > 0.4 ? '#ff9800' : '#f44336';
                const typeBadge = item.inputType ? `<span style="background: #2196F3; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8em;">${item.inputType}</span>` : '';
                
                return `
                    <div class="training-item">
                        <div class="training-content">
                            <strong>Entrada:</strong> ${item.question}<br>
                            <strong>Salida:</strong> ${item.answer}<br>
                            <div style="margin-top: 8px; color: #666; font-size: 0.9em;">
                                <strong>Keywords:</strong> ${item.keywords.slice(0, 6).join(', ')}${item.keywords.length > 6 ? '...' : ''}
                            </div>
                            <div style="margin-top: 8px; display: flex; gap: 15px; font-size: 0.85em; flex-wrap: wrap; align-items: center;">
                                ${typeBadge}
                                <span><strong>Usos:</strong> ${item.useCount}</span>
                                <span><strong>‚úì:</strong> ${item.successCount}</span>
                                <span><strong>‚úó:</strong> ${item.failCount}</span>
                                <span style="color: ${rateColor};"><strong>Tasa:</strong> ${(successRate * 100).toFixed(0)}%</span>
                            </div>
                        </div>
                        <button class="btn-delete" onclick="deleteTraining('${item.id}')">üóëÔ∏è</button>
                    </div>
                `;
            }).join('');
        }

        function saveToStorage() {
            try {
                const dataToSave = {
                    trainingData: trainingData,
                    questionCount: questionCount,
                    conversationContext: conversationContext,
                    deepThinkingMode: deepThinkingMode,
                    lastSaved: new Date().toISOString(),
                    version: '3.3.1'
                };
                localStorage.setItem('aiTrainingData', JSON.stringify(dataToSave));
                return true;
            } catch(e) {
                console.error('Error guardando datos:', e);
                return false;
            }
        }

        function loadFromStorage() {
            try {
                const saved = localStorage.getItem('aiTrainingData');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    trainingData = parsed.trainingData || [];
                    questionCount = parsed.questionCount || 0;
                    conversationContext = parsed.conversationContext || [];
                    deepThinkingMode = parsed.deepThinkingMode || false;
                    
                    document.getElementById('deepThinkingToggle').checked = deepThinkingMode;
                    
                    const statusDiv = document.getElementById('trainStatus');
                    if (trainingData.length > 0) {
                        statusDiv.innerHTML = `<div class="status success">‚úì ${trainingData.length} entrenamientos cargados autom√°ticamente (v${parsed.version || '3.2'})</div>`;
                        setTimeout(() => { statusDiv.innerHTML = ''; }, 3000);
                    }
                    return true;
                }
            } catch(e) {
                console.error('Error cargando datos:', e);
            }
            return false;
        }

        // Funciones de correcci√≥n (sin cambios)
        function correctSpelling(text) {
            let corrected = text;
            const corrections = [];
            
            const words = text.split(/\s+/);
            
            words.forEach(word => {
                const cleanWord = word.toLowerCase().replace(/[.,!?;:]/g, '');
                
                if (spellingCorrections[cleanWord]) {
                    const replacement = spellingCorrections[cleanWord];
                    corrected = corrected.replace(new RegExp('\\b' + word + '\\b', 'gi'), replacement);
                    corrections.push({ before: word, after: replacement });
                }
            });
            
            return { text: corrected, corrections };
        }

        function addAccents(text) {
            let corrected = text;
            const corrections = [];
            
            const isQuestion = text.includes('?') || 
                              /^(como|que|cual|donde|cuando|quien|cuanto)/i.test(text);
            
            if (isQuestion) {
                Object.entries(accentCorrections).forEach(([without, with_]) => {
                    const regex = new RegExp('\\b' + without + '\\b', 'gi');
                    if (regex.test(corrected)) {
                        corrected = corrected.replace(regex, with_);
                        corrections.push({ before: without, after: with_ });
                    }
                });
            }
            
            return { text: corrected, corrections };
        }

        function addPunctuation(text) {
            let corrected = text.trim();
            const corrections = [];
            
            if (!/[.!?]$/.test(corrected)) {
                corrections.push({ before: 'sin punto final', after: 'con punto final' });
                corrected += '.';
            }
            
            if (corrected.length > 0 && corrected[0] !== corrected[0].toUpperCase()) {
                corrections.push({ before: 'min√∫scula inicial', after: 'may√∫scula inicial' });
                corrected = corrected.charAt(0).toUpperCase() + corrected.slice(1);
            }
            
            corrected = corrected.replace(/\.([a-z√°√©√≠√≥√∫√±])/gi, '. $1');
            corrected = corrected.replace(/,([a-z√°√©√≠√≥√∫√±])/gi, ', $1');
            
            corrected = corrected.replace(/\.\s+([a-z√°√©√≠√≥√∫√±])/g, (match, letter) => {
                return '. ' + letter.toUpperCase();
            });
            
            return { text: corrected, corrections };
        }

        function fullCorrection(text) {
            if (!text || text.trim() === '') return { text: '', corrections: [] };
            
            let allCorrections = [];
            
            const spelling = correctSpelling(text);
            let result = spelling.text;
            allCorrections = allCorrections.concat(spelling.corrections);
            
            const accents = addAccents(result);
            result = accents.text;
            allCorrections = allCorrections.concat(accents.corrections);
            
            const punctuation = addPunctuation(result);
            result = punctuation.text;
            allCorrections = allCorrections.concat(punctuation.corrections);
            
            return { text: result, corrections: allCorrections };
        }

        function showCorrections(corrections) {
            const corrDiv = document.getElementById('corrections');
            
            if (corrections.length === 0) {
                corrDiv.style.display = 'none';
                return;
            }
            
            let html = '<h4>‚úçÔ∏è Correcciones aplicadas:</h4>';
            corrections.forEach(corr => {
                html += `
                    <div class="correction-item">
                        <span class="before">${corr.before}</span> ‚Üí 
                        <span class="after">${corr.after}</span>
                    </div>
                `;
            });
            
            corrDiv.innerHTML = html;
            corrDiv.style.display = 'block';
        }

        function normalizeText(text) {
            return text.toLowerCase()
                .normalize("NFD")
                .replace(/[\u0300-\u036f]/g, "")
                .replace(/[^\w\s]/g, " ")
                .replace(/\s+/g, " ")
                .trim();
        }

        function stem(word) {
            const suffixes = ['ando', 'iendo', 'mente', 'aci√≥n', 'ador', 'ante', 'ancia', 'encia', 
                            'ible', 'able', 'ismo', 'ista', 'oso', 'osa', 'ivo', 'iva',
                            'ar', 'er', 'ir', 'ado', 'ido', 'es', 'as', 'os', 's'];
            
            for (let suffix of suffixes) {
                if (word.length > suffix.length + 3 && word.endsWith(suffix)) {
                    return word.slice(0, -suffix.length);
                }
            }
            return word;
        }

        function tokenize(text) {
            const normalized = normalizeText(text);
            const words = normalized.split(/\s+/).filter(w => w.length > 0);
            const stems = words.map(w => stem(w));
            
            const bigrams = [];
            const trigrams = [];
            for (let i = 0; i < words.length - 1; i++) {
                bigrams.push(words[i] + ' ' + words[i + 1]);
                if (i < words.length - 2) {
                    trigrams.push(words[i] + ' ' + words[i + 1] + ' ' + words[i + 2]);
                }
            }
            
            const vocalPattern = analyzeVowelPattern(text);
            
            return { words, stems, normalized, bigrams, trigrams, vocalPattern };
        }

        function extractKeywords(text) {
            const { words } = tokenize(text);
            
            const commonWords = new Set([
                'que', 'qu√©', 'como', 'c√≥mo', 'para', 'por', 'con', 'de', 'en', 'la', 'el', 'los', 'las',
                'un', 'una', 'unos', 'unas', 'y', 'o', 'pero', 'si', 'no', 'es', 'son', 'soy', 'eres',
                'esta', 'este', 'estos', 'estas', 'al', 'del', 'lo', 'le', 'se', 'te', 'me', 'nos', 'os',
                'su', 'sus', 'mi', 'mis', 'tu', 'tus', 'a', 'ante', 'bajo', 'desde', 'entre', 'hacia',
                'hasta', 'seg√∫n', 'sin', 'sobre', 'tras', 'ser', 'estar', 'hay', 'tener'
            ]);
            
            const keywords = words.filter(word => word.length > 2 && !commonWords.has(word));
            
            const expandedKeywords = new Set(keywords);
            keywords.forEach(keyword => {
                if (synonyms[keyword]) {
                    synonyms[keyword].forEach(syn => expandedKeywords.add(syn));
                }
                Object.entries(synonyms).forEach(([key, syns]) => {
                    if (syns.includes(keyword)) {
                        expandedKeywords.add(key);
                    }
                });
                
                const variations = generateVowelVariations(keyword);
                variations.forEach(v => expandedKeywords.add(v));
                const alphaVars = generateAlphabetVariations(keyword); // Nueva
                alphaVars.forEach(v => expandedKeywords.add(v));
            });
            
            return [...expandedKeywords];
        }

        function levenshtein(str1, str2) {
            const len1 = str1.length;
            const len2 = str2.length;
            const matrix = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));

            for (let i = 0; i <= len1; i++) matrix[i][0] = i;
            for (let j = 0; j <= len2; j++) matrix[0][j] = j;

            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1,
                        matrix[i][j - 1] + 1,
                        matrix[i - 1][j - 1] + cost
                    );
                }
            }

            const maxLen = Math.max(len1, len2);
            return maxLen === 0 ? 1 : 1 - (matrix[len1][len2] / maxLen);
        }

        function calculateSemanticRelevance(userInput, sentence) {
            const userTokens = tokenize(userInput);
            const sentTokens = tokenize(sentence);
            
            const commonKeywords = [...new Set(userTokens.words)].filter(w => 
                sentTokens.words.includes(w) && w.length > 3
            ).length;
            
            const similarity = calculateSimilarity(userInput, sentence);
            
            const vocalMatch = compareVocalPatterns(userInput, sentence);
            const alphaMatch = compareAlphabetPatterns(userInput, sentence); // Nueva
            
            const lengthPenalty = Math.abs(sentence.length - userInput.length) / Math.max(sentence.length, userInput.length);
            
            const logicalScore = commonKeywords * 10 + similarity * 0.25 + vocalMatch * 0.15 + alphaMatch * 0.15 - lengthPenalty * 30;
            
            return logicalScore;
        }

        function analyzeVowelPattern(text) {
            const vowels = ['a', 'e', 'i', 'o', 'u', '√°', '√©', '√≠', '√≥', '√∫'];
            const consonants = 'bcdfghjklmnpqrstvwxyz';
            
            const normalized = text.toLowerCase();
            let vocalPattern = '';
            let consonantPattern = '';
            let vocalCount = {};
            let consonantCount = {};
            
            for (let char of normalized) {
                if (vowels.includes(char)) {
                    vocalPattern += 'V';
                    vocalCount[char] = (vocalCount[char] || 0) + 1;
                } else if (consonants.includes(char)) {
                    consonantPattern += 'C';
                    consonantCount[char] = (consonantCount[char] || 0) + 1;
                }
            }
            
            const totalVowels = Object.values(vocalCount).reduce((a, b) => a + b, 0);
            const totalConsonants = Object.values(consonantCount).reduce((a, b) => a + b, 0);
            
            const vocalRatio = totalVowels / (totalVowels + totalConsonants || 1);
            
            const vocalSignature = Object.keys(vocalCount).sort().join('');
            const consonantSignature = Object.keys(consonantCount).sort().join('');
            
            return {
                vocalPattern,
                consonantPattern,
                vocalCount,
                consonantCount,
                totalVowels,
                totalConsonants,
                vocalRatio,
                vocalSignature,
                consonantSignature,
                fullSignature: vocalSignature + consonantSignature
            };
        }

        function generateVowelVariations(word) {
            const variations = [word];
            const vowelMap = {
                'a': ['a', '√°'], 'e': ['e', '√©'], 'i': ['i', '√≠'],
                'o': ['o', '√≥'], 'u': ['u', '√∫'],
                '√°': ['a', '√°'], '√©': ['e', '√©'], '√≠': ['i', '√≠'],
                '√≥': ['o', '√≥'], '√∫': ['u', '√∫']
            };
            
            for (let i = 0; i < word.length; i++) {
                const char = word[i].toLowerCase();
                if (vowelMap[char]) {
                    vowelMap[char].forEach(variant => {
                        if (variant !== char) {
                            const newWord = word.substring(0, i) + variant + word.substring(i + 1);
                            variations.push(newWord);
                        }
                    });
                }
            }
            
            return variations;
        }

        function compareVocalPatterns(pattern1, pattern2) {
            const p1 = analyzeVowelPattern(pattern1);
            const p2 = analyzeVowelPattern(pattern2);
            
            let score = 0;
            
            if (p1.vocalSignature === p2.vocalSignature) {
                score += 25;
            } else {
                const commonVowels = Object.keys(p1.vocalCount).filter(v => p2.vocalCount[v]);
                score += commonVowels.length * 5;
            }
            
            if (p1.consonantSignature === p2.consonantSignature) {
                score += 20;
            } else {
                const commonConsonants = Object.keys(p1.consonantCount).filter(c => p2.consonantCount[c]);
                score += commonConsonants.length * 3;
            }
            
            const ratioDiff = Math.abs(p1.vocalRatio - p2.vocalRatio);
            score += (1 - ratioDiff) * 15;
            
            const lengthRatio = Math.min(p1.vocalPattern.length, p2.vocalPattern.length) / 
                               Math.max(p1.vocalPattern.length, p2.vocalPattern.length);
            score += lengthRatio * 10;
            
            return score;
        }

        function findMatches(userInput) {
            const matches = [];
            const userTokens = tokenize(userInput);
            const userKeywords = extractKeywords(userInput);
            
            trainingData.forEach((item, index) => {
                let score = 0;
                const details = [];
                
                const qSimilarity = calculateSimilarity(userInput, item.question);
                const semanticQ = calculateSemanticRelevance(userInput, item.question);
                score += (qSimilarity * 0.5) + (semanticQ * 0.2);
                if (qSimilarity > 10) details.push(`Pregunta: ${qSimilarity.toFixed(0)}%`);
                
                const aSimilarity = calculateSimilarity(userInput, item.answer);
                const semanticA = calculateSemanticRelevance(userInput, item.answer);
                score += (aSimilarity * 0.15) + (semanticA * 0.1);
                
                const vocalScore = compareVocalPatterns(userInput, item.question);
                score += vocalScore * 0.05;
                if (vocalScore > 20) details.push(`Patr√≥n Vocal: ${vocalScore.toFixed(0)}%`);
                
                const alphaScore = compareAlphabetPatterns(userInput, item.question); // Nueva
                score += alphaScore * 0.05;
                if (alphaScore > 20) details.push(`Abecedario: ${alphaScore.toFixed(0)}%`);
                
                const keywordMatches = [];
                userKeywords.forEach(userKw => {
                    item.keywords.forEach(itemKw => {
                        if (userKw === itemKw || 
                            (synonyms[userKw] && synonyms[userKw].includes(itemKw)) ||
                            (synonyms[itemKw] && synonyms[itemKw].includes(userKw))) {
                            keywordMatches.push(itemKw);
                        }
                    });
                });
                
                if (keywordMatches.length > 0) {
                    score += keywordMatches.length * 15;
                    details.push(`Keywords: ${keywordMatches.length}`);
                }
                
                const bigramMatches = item.questionBigrams.filter(bg => userTokens.bigrams.includes(bg));
                if (bigramMatches.length > 0) {
                    score += bigramMatches.length * 20;
                    details.push(`Bigramas: ${bigramMatches.length}`);
                }
                
                const trigramMatches = item.questionTrigrams.filter(tg => userTokens.trigrams.includes(tg));
                if (trigramMatches.length > 0) {
                    score += trigramMatches.length * 30;
                    details.push(`Trigramas: ${trigramMatches.length}`);
                }
                
                const stemMatches = item.questionStems.filter(stem => userTokens.stems.includes(stem));
                if (stemMatches.length > 0) {
                    score += stemMatches.length * 15;
                }
                
                if (item.successCount > 0) {
                    const successRate = item.successCount / (item.successCount + item.failCount || 1);
                    score += successRate * 20;
                    if (successRate > 0.5) details.push(`√âxito: ${(successRate * 100).toFixed(0)}%`);
                }
                
                if (conversationContext.length > 0) {
                    conversationContext.forEach(ctx => {
                        const ctxSim = calculateSimilarity(ctx, item.question);
                        if (ctxSim > 35) {
                            score += 20;
                            details.push('Contexto+');
                        }
                    });
                }
                
                // Boost por tipo coincidente
                if (item.inputType === classifyInput(userInput).type) {
                    score += 25;
                    details.push('Tipo match');
                }
                
                if (score > 0) {
                    matches.push({ item, index, score: Math.min(score, 100), details });
                }
            });
            
            matches.sort((a, b) => b.score - a.score);
            return matches;
        }

        function giveFeedback(isPositive) {
            if (lastUsedSources.length === 0) return;
            
            lastUsedSources.forEach(idx => {
                if (trainingData[idx]) {
                    trainingData[idx].useCount++;
                    if (isPositive) {
                        trainingData[idx].successCount++;
                    } else {
                        trainingData[idx].failCount++;
                    }
                }
            });
            
            saveToStorage();
            
            document.getElementById('feedbackSection').innerHTML = `
                <div class="status success">
                    ${isPositive ? '‚úì ¬°Gracias! IA mejorada y guardada' : '‚úì Registrado y guardado, ajustando pesos'}
                </div>
            `;
            updateStats();
            viewTraining();
        }

        function downloadTraining() {
            const statusDiv = document.getElementById('trainStatus');
            
            if (trainingData.length === 0) {
                statusDiv.innerHTML = '<div class="status error">Sin datos</div>';
                return;
            }

            const dataToExport = {
                version: '3.3.1',
                exportDate: new Date().toISOString(),
                trainingData: trainingData,
                questionCount: questionCount,
                conversationContext: conversationContext,
                deepThinkingMode: deepThinkingMode
            };

            const dataStr = JSON.stringify(dataToExport, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `ia-ultra-vocal-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(url);

            statusDiv.innerHTML = '<div class="status success">‚úì Descargado</div>';
            setTimeout(() => { statusDiv.innerHTML = ''; }, 3000);
        }

        function loadTraining(event) {
            const file = event.target.files[0];
            const statusDiv = document.getElementById('trainStatus');
            
            if (!file) return;

            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (!importedData.trainingData) {
                        throw new Error('Formato inv√°lido');
                    }

                    const loadedCount = importedData.trainingData.length;
                    
                    if (trainingData.length > 0) {
                        if (confirm(`Tienes ${trainingData.length} entrenamientos guardados.\n\nOK = Reemplazar todo\nCancelar = Agregar al existente`)) {
                            trainingData = importedData.trainingData;
                        } else {
                            trainingData = [...trainingData, ...importedData.trainingData];
                        }
                    } else {
                        trainingData = importedData.trainingData;
                    }
                    
                    if (importedData.questionCount) {
                        questionCount = importedData.questionCount;
                    }
                    
                    if (importedData.conversationContext) {
                        conversationContext = importedData.conversationContext;
                    }

                    if (importedData.deepThinkingMode !== undefined) {
                        deepThinkingMode = importedData.deepThinkingMode;
                        document.getElementById('deepThinkingToggle').checked = deepThinkingMode;
                    }
                    
                    saveToStorage();
                    
                    statusDiv.innerHTML = `<div class="status success">‚úì ${loadedCount} entrenamientos cargados y guardados autom√°ticamente</div>`;
                    updateStats();
                    viewTraining();
                    
                    setTimeout(() => { statusDiv.innerHTML = ''; }, 4000);
                    
                } catch (error) {
                    statusDiv.innerHTML = `<div class="status error">Error: ${error.message}</div>`;
                }
            };
            
            reader.readAsText(file);
            event.target.value = '';
        }

        function calculateTotalWords() {
            const allWords = new Set();
            trainingData.forEach(item => {
                item.questionWords.forEach(w => allWords.add(w));
                item.answerWords.forEach(w => allWords.add(w));
            });
            return allWords.size;
        }

        function clearAllTraining() {
            if (!confirm('¬øBORRAR TODO el entrenamiento guardado?')) return;

            trainingData = [];
            questionCount = 0;
            conversationContext = [];
            lastUsedSources = [];
            
            saveToStorage();
            
            document.getElementById('trainStatus').innerHTML = '<div class="status success">‚úì Todo borrado y guardado</div>';
            updateStats();
            viewTraining();
        }

        function updateStats() {
            document.getElementById('totalTraining').textContent = trainingData.length;
            document.getElementById('totalQuestions').textContent = questionCount;
            document.getElementById('totalWords').textContent = calculateTotalWords();
            
            const size = new Blob([JSON.stringify(trainingData)]).size;
            document.getElementById('dbSize').textContent = (size / 1024).toFixed(2) + ' KB';
        }

        function updateAutoTags() {
            const question = document.getElementById('question').value.trim();
            const answer = document.getElementById('answer').value.trim();
            
            if (!question && !answer) {
                document.getElementById('autoTags').style.display = 'none';
                return;
            }
            
            const keywords = extractKeywords(question + ' ' + answer);
            const uniqueKeywords = [...new Set(keywords)];
            
            if (uniqueKeywords.length > 0) {
                document.getElementById('tagsList').innerHTML = uniqueKeywords.slice(0, 8).map(tag => 
                    `<span>${tag}</span>`
                ).join('') + (uniqueKeywords.length > 8 ? '<span>...</span>' : '');
                document.getElementById('autoTags').style.display = 'block';
            } else {
                document.getElementById('autoTags').style.display = 'none';
            }
        }

        function deleteTraining(id) {
            if (!confirm('¬øEliminar?')) return;
            
            trainingData = trainingData.filter(item => item.id !== id);
            saveToStorage();
            
            const statusDiv = document.getElementById('trainStatus');
            statusDiv.innerHTML = '<div class="status success">‚úì Eliminado y guardado</div>';
            setTimeout(() => { statusDiv.innerHTML = ''; }, 2000);
            
            updateStats();
            viewTraining();
        }

        document.addEventListener('input', updateAutoTags);
        document.getElementById('question').addEventListener('input', updateAutoTags);
        document.getElementById('answer').addEventListener('input', updateAutoTags);

        window.addEventListener('load', () => {
            loadFromStorage();
            updateStats();
            viewTraining();
        });
    </script>
</body>
</html>