<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IA Ultra Avanzada V3 - An√°lisis Multinivel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header .badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            margin: 5px;
            font-size: 0.85em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }

        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
        }

        .btn-info {
            background: linear-gradient(135deg, #2196F3 0%, #0d8bf2 100%);
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .btn-delete {
            background: #f44336;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
        }

        .btn-delete:hover {
            background: #d32f2f;
            transform: scale(1.05);
        }

        .response-box {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #667eea;
            min-height: 150px;
            margin-top: 15px;
            max-height: 500px;
            overflow-y: auto;
        }

        .training-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
        }

        .training-content {
            flex: 1;
        }

        .training-item strong {
            color: #667eea;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .stat-card .number {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-card .label {
            color: #666;
            margin-top: 5px;
        }

        .status {
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
            font-weight: 600;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }

        .status.warning {
            background: #fff3cd;
            color: #856404;
        }

        .analysis {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid #2196F3;
        }

        .analysis-item {
            margin: 5px 0;
            color: #0d47a1;
        }

        .match-score {
            display: inline-block;
            background: #4caf50;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .combined-badge {
            display: inline-block;
            background: #ff9800;
            color: white;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: bold;
            margin-left: 10px;
        }

        .source-list {
            background: #f0f4f8;
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
            font-size: 0.9em;
        }

        .source-item {
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        .source-weight {
            display: inline-block;
            background: #e3f2fd;
            color: #1976d2;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .auto-tags {
            background: #f0f8ff;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .auto-tags span {
            display: inline-block;
            background: #e1f5fe;
            padding: 3px 8px;
            border-radius: 12px;
            margin: 2px;
            font-size: 0.8em;
        }

        .correction-box {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .correction-box h4 {
            color: #856404;
            margin-bottom: 8px;
        }

        .correction-item {
            background: white;
            padding: 6px 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #ff9800;
        }

        .correction-item .before {
            text-decoration: line-through;
            color: #d32f2f;
        }

        .correction-item .after {
            color: #388e3c;
            font-weight: bold;
        }

        .feedback-btns {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .feedback-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: transform 0.2s;
        }

        .feedback-btn:hover {
            transform: scale(1.05);
        }

        .feedback-good {
            background: #4caf50;
            color: white;
        }

        .feedback-bad {
            background: #f44336;
            color: white;
        }

        #fileInput {
            display: none;
        }

        .generated-response {
            background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
            padding: 18px;
            border-radius: 10px;
            margin: 12px 0;
            border-left: 4px solid #4caf50;
            line-height: 1.8;
            font-size: 1.05em;
        }

        .coherence-badge {
            display: inline-block;
            background: #9c27b0;
            color: white;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: bold;
            margin-left: 10px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .btn-group {
                grid-template-columns: 1fr;
            }

            .training-item {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† IA Ultra Avanzada V3</h1>
            <p>An√°lisis Multinivel: Alfab√©tico + Fon√©tico + Gramatical + Sem√°ntico + L√≥gico</p>
            <div>
                <span class="badge">üî§ An√°lisis Alfab√©tico</span>
                <span class="badge">üéØ Jaro-Winkler</span>
                <span class="badge">üìñ An√°lisis Gramatical</span>
                <span class="badge">üß¨ N-gramas Caracteres</span>
                <span class="badge">üîç Validaci√≥n L√≥gica</span>
                <span class="badge">‚ö° TF-IDF</span>
            </div>
        </div>

        <div class="main-content">
            <div class="section">
                <h2>üìö Entrenar IA</h2>
                <div class="input-group">
                    <label for="question">Pregunta / Entrada:</label>
                    <textarea id="question" placeholder="Escribe aqu√≠... (An√°lisis multinivel autom√°tico)"></textarea>
                </div>
                <div class="input-group">
                    <label for="answer">Respuesta / Salida:</label>
                    <textarea id="answer" placeholder="Escribe la respuesta completa y l√≥gica..."></textarea>
                </div>
                <div id="corrections" class="correction-box" style="display:none;"></div>
                <div id="autoTags" class="auto-tags" style="display:none;">
                    <strong>An√°lisis:</strong> <span id="tagsList"></span>
                </div>
                <button class="btn" onclick="trainAI()">‚úÖ Entrenar IA Avanzada</button>
                <button class="btn btn-secondary" onclick="viewTraining()">Ver Entrenamiento</button>
                
                <div class="btn-group">
                    <button class="btn btn-success" onclick="downloadTraining()">üì• Descargar</button>
                    <button class="btn btn-info" onclick="document.getElementById('fileInput').click()">üì§ Cargar</button>
                </div>
                <input type="file" id="fileInput" accept=".json" onchange="loadTraining(event)">
                
                <button class="btn btn-danger" onclick="clearAllTraining()">üóëÔ∏è Borrar Todo</button>
                <div id="trainStatus"></div>
            </div>

            <div class="section">
                <h2>üí¨ Consultar IA</h2>
                <div class="input-group">
                    <label for="userQuestion">Pregunta:</label>
                    <textarea id="userQuestion" placeholder="Escribe tu pregunta... La IA usar√° 7 m√©todos avanzados para encontrar la mejor respuesta"></textarea>
                </div>
                <button class="btn" onclick="askAI()">üöÄ Consultar IA Avanzada</button>
                <div class="response-box" id="aiResponse">
                    La IA analizar√° tu pregunta con 7 m√©todos avanzados: alfab√©tico, fon√©tico, gramatical, sem√°ntico, n-gramas, TF-IDF y validaci√≥n l√≥gica...
                </div>
                <div id="feedbackSection"></div>
                <div id="analysis"></div>
            </div>

            <div class="section" style="grid-column: 1 / -1;">
                <h2>üìä Estad√≠sticas</h2>
                <div class="stats">
                    <div class="stat-card">
                        <div class="number" id="totalTraining">0</div>
                        <div class="label">Entrenamientos</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="totalWords">0</div>
                        <div class="label">Palabras √önicas</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="totalQuestions">0</div>
                        <div class="label">Consultas</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="dbSize">0 KB</div>
                        <div class="label">Tama√±o BD</div>
                    </div>
                </div>
            </div>

            <div class="section" style="grid-column: 1 / -1;">
                <h2>üìù Base de Conocimiento</h2>
                <div id="trainingList"></div>
            </div>
        </div>
    </div>

    <script>
        let trainingData = [];
        let questionCount = 0;
        let conversationContext = [];
        let lastUsedSources = [];
        let idfScores = {};

        const synonyms = {
            'hola': ['saludos', 'buenas', 'hey', 'alo', 'que tal', 'hi'],
            'adios': ['chao', 'hasta luego', 'nos vemos', 'bye'],
            'gracias': ['muchas gracias', 'agradecido', 'thanks', 'agradezco'],
            'ayuda': ['ayudar', 'asistencia', 'soporte', 'auxilio', 'apoyo'],
            'como': ['de que manera', 'de que forma', 'de que modo'],
            'que': ['cual', 'cuales', 'qu√©'],
            'hacer': ['realizar', 'ejecutar', 'crear', 'efectuar'],
            'bueno': ['bien', 'excelente', 'genial', 'perfecto', 'magnifico'],
            'malo': ['mal', 'pesimo', 'terrible', 'horrible'],
            'programar': ['programacion', 'codificar', 'codigo', 'desarrollar', 'software'],
            'javascript': ['js', 'ecmascript', 'node'],
            'python': ['py', 'django', 'flask'],
            'aprender': ['estudiar', 'ensenar', 'educacion', 'capacitar']
        };

        const spellingCorrections = {
            'q': 'que', 'xq': 'porque', 'pq': 'porque', 'xk': 'porque',
            'tb': 'tambi√©n', 'tmb': 'tambi√©n', 'bn': 'bien',
            'd': 'de', 'k': 'que', 'x': 'por', 'pa': 'para',
            'porfa': 'por favor', 'porfavor': 'por favor',
            'ola': 'hola', 'aver': 'a ver', 'aber': 'a ver',
            'aslo': 'hazlo', 'ase': 'hace', 'ahy': 'ah√≠',
            'komo': 'como', 'kien': 'quien',
            'xfa': 'por favor', 'porq': 'porque',
            'bro': 'hermano', 'wey': 'amigo'
        };

        const accentCorrections = {
            'como': 'c√≥mo', 'que': 'qu√©', 'cual': 'cu√°l', 'donde': 'd√≥nde',
            'cuando': 'cu√°ndo', 'quien': 'qui√©n', 'cuanto': 'cu√°nto',
            'mas': 'm√°s', 'si': 's√≠', 'tu': 't√∫', 'mi': 'm√≠',
            'esta': 'est√°', 'estas': 'est√°s',
            'razon': 'raz√≥n', 'informacion': 'informaci√≥n',
            'codigo': 'c√≥digo', 'tambien': 'tambi√©n', 'ahi': 'ah√≠',
            'dia': 'd√≠a', 'despues': 'despu√©s', 'facil': 'f√°cil',
            'dificil': 'dif√≠cil', 'util': '√∫til'
        };

        // ===== AN√ÅLISIS ALFAB√âTICO Y FON√âTICO AVANZADO =====
        function jaroWinkler(s1, s2) {
            const m = s1.length;
            const n = s2.length;
            
            if (m === 0) return n === 0 ? 1.0 : 0.0;
            if (n === 0) return 0.0;
            
            const matchWindow = Math.floor(Math.max(m, n) / 2) - 1;
            const s1Matches = new Array(m).fill(false);
            const s2Matches = new Array(n).fill(false);
            
            let matches = 0;
            let transpositions = 0;
            
            for (let i = 0; i < m; i++) {
                const start = Math.max(0, i - matchWindow);
                const end = Math.min(i + matchWindow + 1, n);
                
                for (let j = start; j < end; j++) {
                    if (s2Matches[j]) continue;
                    if (s1[i] !== s2[j]) continue;
                    s1Matches[i] = true;
                    s2Matches[j] = true;
                    matches++;
                    break;
                }
            }
            
            if (matches === 0) return 0.0;
            
            let k = 0;
            for (let i = 0; i < m; i++) {
                if (!s1Matches[i]) continue;
                while (!s2Matches[k]) k++;
                if (s1[i] !== s2[k]) transpositions++;
                k++;
            }
            
            const jaro = (matches / m + matches / n + (matches - transpositions / 2) / matches) / 3.0;
            
            let prefix = 0;
            for (let i = 0; i < Math.min(m, n, 4); i++) {
                if (s1[i] === s2[i]) prefix++;
                else break;
            }
            
            return jaro + prefix * 0.1 * (1.0 - jaro);
        }

        function characterNGrams(text, n) {
            const ngrams = [];
            const clean = text.toLowerCase().replace(/\s+/g, '');
            for (let i = 0; i <= clean.length - n; i++) {
                ngrams.push(clean.substring(i, i + n));
            }
            return ngrams;
        }

        function characterSimilarity(text1, text2) {
            const ngrams1_2 = new Set(characterNGrams(text1, 2));
            const ngrams2_2 = new Set(characterNGrams(text2, 2));
            const ngrams1_3 = new Set(characterNGrams(text1, 3));
            const ngrams2_3 = new Set(characterNGrams(text2, 3));
            
            const intersection2 = new Set([...ngrams1_2].filter(x => ngrams2_2.has(x)));
            const union2 = new Set([...ngrams1_2, ...ngrams2_2]);
            const jaccard2 = union2.size === 0 ? 0 : intersection2.size / union2.size;
            
            const intersection3 = new Set([...ngrams1_3].filter(x => ngrams2_3.has(x)));
            const union3 = new Set([...ngrams1_3, ...ngrams2_3]);
            const jaccard3 = union3.size === 0 ? 0 : intersection3.size / union3.size;
            
            return (jaccard2 * 0.4 + jaccard3 * 0.6) * 100;
        }

        function phoneticMatch(word1, word2) {
            const simplify = (w) => {
                return w.toLowerCase()
                    .replace(/[√°√†√§√¢]/g, 'a')
                    .replace(/[√©√®√´√™]/g, 'e')
                    .replace(/[√≠√¨√Ø√Æ]/g, 'i')
                    .replace(/[√≥√≤√∂√¥]/g, 'o')
                    .replace(/[√∫√π√º√ª]/g, 'u')
                    .replace(/√±/g, 'n')
                    .replace(/[^a-z]/g, '');
            };
            
            const s1 = simplify(word1);
            const s2 = simplify(word2);
            
            return jaroWinkler(s1, s2);
        }

        // ===== AN√ÅLISIS GRAMATICAL AVANZADO =====
        function analyzeGrammar(text) {
            const lower = text.toLowerCase();
            
            const hasSubject = /\b(yo|t√∫|√©l|ella|nosotros|ellos|esto|eso|aquello|la|el|un|una|los|las)\b/i.test(text);
            
            const verbs = ['es', 'son', 'est√°', 'est√°n', 'fue', 'fueron', 'ser√°', 'ser√°n',
                          'tiene', 'tienen', 'hace', 'hacen', 'puede', 'pueden',
                          'debe', 'deben', 'sabe', 'saben', 'quiere', 'quieren',
                          'va', 'van', 'viene', 'vienen', 'usa', 'usan',
                          'permite', 'permite', 'ayuda', 'ayudan'];
            const hasVerb = verbs.some(v => new RegExp('\\b' + v + '\\b', 'i').test(lower));
            
            const hasComplement = /\b(con|sin|para|por|en|de|desde|hasta|sobre|bajo|entre)\b/i.test(lower);
            
            const hasArticle = /\b(el|la|los|las|un|una|unos|unas)\b/i.test(lower);
            
            const hasPunctuation = /[.!?]$/.test(text.trim());
            
            const isQuestion = /^(qu√©|c√≥mo|cu√°l|d√≥nde|cu√°ndo|qui√©n|por qu√©|para qu√©)/i.test(lower) || text.includes('?');
            
            let grammarScore = 0;
            if (hasSubject) grammarScore += 25;
            if (hasVerb) grammarScore += 30;
            if (hasComplement) grammarScore += 15;
            if (hasArticle) grammarScore += 10;
            if (hasPunctuation) grammarScore += 15;
            if (text.length > 20) grammarScore += 5;
            
            return {
                score: grammarScore,
                hasSubject,
                hasVerb,
                hasComplement,
                isQuestion,
                isComplete: grammarScore >= 65
            };
        }

        function sentenceStructureScore(text) {
            const grammar = analyzeGrammar(text);
            const words = text.split(/\s+/).length;
            
            let score = grammar.score;
            
            if (words >= 5 && words <= 30) score += 15;
            else if (words > 30 && words <= 50) score += 10;
            else if (words < 5) score -= 20;
            
            const capsCount = (text.match(/[A-Z√Å√â√ç√ì√ö]/g) || []).length;
            if (capsCount > 0 && capsCount < text.length * 0.3) score += 5;
            
            if (!/\b(xd|jaja|lol|jeje)\b/i.test(text)) score += 10;
            
            return Math.min(100, Math.max(0, score));
        }

        // ===== C√ÅLCULO TF-IDF =====
        function calculateIDF() {
            const documentCount = trainingData.length;
            const termDocCount = {};
            
            trainingData.forEach(item => {
                const uniqueWords = new Set([...item.questionWords, ...item.answerWords]);
                uniqueWords.forEach(word => {
                    termDocCount[word] = (termDocCount[word] || 0) + 1;
                });
            });
            
            idfScores = {};
            Object.entries(termDocCount).forEach(([term, count]) => {
                idfScores[term] = Math.log(documentCount / count);
            });
        }

        function calculateTFIDF(words) {
            const tf = {};
            words.forEach(word => {
                tf[word] = (tf[word] || 0) + 1;
            });
            
            const tfidf = {};
            Object.entries(tf).forEach(([term, freq]) => {
                const idf = idfScores[term] || Math.log(trainingData.length + 1);
                tfidf[term] = freq * idf;
            });
            
            return tfidf;
        }

        // ===== VALIDACI√ìN L√ìGICA PROFUNDA =====
        function hasLogicalSense(text) {
            const lower = text.toLowerCase();
            
            const nonsensePhrases = [
                /\bno\s+(tengo|tiene|tienen)\s+acceso\s+ah\s+internet/i,
                /\bno\s+digas\s+mamadas/i,
                /\bno\s+lose\b/i,
                /\bpues\s+no\b.*\bxd\b/i
            ];
            
            if (nonsensePhrases.some(pattern => pattern.test(text))) {
                return false;
            }
            
            const grammar = analyzeGrammar(text);
            if (!grammar.hasVerb && text.split(/\s+/).length > 3) {
                return false;
            }
            
            const fragmentPattern = /^(xd|lol|jaja|bien|mal|si|no|ok|ah|eh|oh)\.?$/i;
            if (fragmentPattern.test(text.trim())) {
                return false;
            }
            
            const words = text.split(/\s+/);
            if (words.length < 4 && !grammar.isComplete) {
                return false;
            }
            
            return true;
        }

        function detectContradiction(text1, text2) {
            const lower1 = text1.toLowerCase();
            const lower2 = text2.toLowerCase();
            
            const negWords = ['no', 'nunca', 'jam√°s', 'nadie', 'nada', 'ning√∫n', 'ninguno'];
            const hasNeg1 = negWords.some(w => new RegExp('\\b' + w + '\\b').test(lower1));
            const hasNeg2 = negWords.some(w => new RegExp('\\b' + w + '\\b').test(lower2));
            
            if (hasNeg1 !== hasNeg2) {
                const commonWords = tokenize(text1).words.filter(w => 
                    tokenize(text2).words.includes(w)
                ).length;
                
                if (commonWords >= 2) {
                    return true;
                }
            }
            
            const opposite = {
                'bueno': 'malo', 'bien': 'mal', 'si': 'no', 'puede': 'no puede',
                'tiene': 'no tiene', 'sabe': 'no sabe', 'hace': 'no hace'
            };
            
            for (const [pos, neg] of Object.entries(opposite)) {
                if ((lower1.includes(pos) && lower2.includes(neg)) ||
                    (lower1.includes(neg) && lower2.includes(pos))) {
                    return true;
                }
            }
            
            return false;
        }

        // ===== CORRECCI√ìN ORTOGR√ÅFICA =====
        function fullCorrection(text) {
            if (!text || text.trim() === '') return { text: '', corrections: [] };
            
            let result = text;
            const corrections = [];
            
            const words = text.split(/\s+/);
            words.forEach(word => {
                const cleanWord = word.toLowerCase().replace(/[.,!?;:]/g, '');
                if (spellingCorrections[cleanWord]) {
                    const replacement = spellingCorrections[cleanWord];
                    result = result.replace(new RegExp('\\b' + word + '\\b', 'gi'), replacement);
                    corrections.push({ before: word, after: replacement });
                }
            });
            
            const isQuestion = result.includes('?') || /^(como|que|cual|donde|cuando|quien|cuanto)/i.test(result);
            if (isQuestion) {
                Object.entries(accentCorrections).forEach(([without, with_]) => {
                    const regex = new RegExp('\\b' + without + '\\b', 'gi');
                    if (regex.test(result)) {
                        result = result.replace(regex, with_);
                        corrections.push({ before: without, after: with_ });
                    }
                });
            }
            
            result = result.trim();
            if (!/[.!?]$/.test(result)) {
                result += '.';
                corrections.push({ before: 'sin punto', after: 'con punto' });
            }
            
            if (result.length > 0 && result[0] !== result[0].toUpperCase()) {
                result = result.charAt(0).toUpperCase() + result.slice(1);
                corrections.push({ before: 'min√∫scula', after: 'May√∫scula' });
            }
            
            return { text: result, corrections };
        }

        // ===== TOKENIZACI√ìN =====
        function normalizeText(text) {
            return text.toLowerCase()
                .normalize("NFD")
                .replace(/[\u0300-\u036f]/g, "")
                .replace(/[^\w\s]/g, " ")
                .replace(/\s+/g, " ")
                .trim();
        }

        function stem(word) {
            const suffixes = ['ando', 'iendo', 'mente', 'aci√≥n', 'ador', 'ante', 'ancia', 'encia', 
                            'ible', 'able', 'ismo', 'ista', 'oso', 'osa', 'ivo', 'iva',
                            'ar', 'er', 'ir', 'ado', 'ido', 'es', 'as', 'os', 's'];
            
            for (let suffix of suffixes) {
                if (word.length > suffix.length + 3 && word.endsWith(suffix)) {
                    return word.slice(0, -suffix.length);
                }
            }
            return word;
        }

        function tokenize(text) {
            const normalized = normalizeText(text);
            const words = normalized.split(/\s+/).filter(w => w.length > 0);
            const stems = words.map(w => stem(w));
            
            const bigrams = [];
            const trigrams = [];
            for (let i = 0; i < words.length - 1; i++) {
                bigrams.push(words[i] + ' ' + words[i + 1]);
                if (i < words.length - 2) {
                    trigrams.push(words[i] + ' ' + words[i + 1] + ' ' + words[i + 2]);
                }
            }
            
            return { words, stems, normalized, bigrams, trigrams };
        }

        function extractKeywords(text) {
            const { words } = tokenize(text);
            
            const commonWords = new Set([
                'que', 'qu√©', 'como', 'c√≥mo', 'para', 'por', 'con', 'de', 'en', 'la', 'el', 'los', 'las',
                'un', 'una', 'unos', 'unas', 'y', 'o', 'pero', 'si', 'no', 'es', 'son', 'soy', 'eres',
                'esta', 'este', 'estos', 'estas', 'al', 'del', 'lo', 'le', 'se', 'te', 'me', 'nos', 'os',
                'su', 'sus', 'mi', 'mis', 'tu', 'tus', 'a', 'ante', 'bajo', 'desde', 'entre', 'hacia',
                'hasta', 'seg√∫n', 'sin', 'sobre', 'tras', 'ser', 'estar', 'hay', 'tener'
            ]);
            
            const keywords = words.filter(word => word.length > 2 && !commonWords.has(word));
            
            const expandedKeywords = new Set(keywords);
            keywords.forEach(keyword => {
                if (synonyms[keyword]) {
                    synonyms[keyword].forEach(syn => expandedKeywords.add(syn));
                }
            });
            
            return [...expandedKeywords];
        }

        // ===== SIMILARIDAD MULTINIVEL AVANZADA =====
        function advancedSimilarity(text1, text2) {
            const tokens1 = tokenize(text1);
            const tokens2 = tokenize(text2);
            
            // 1. Similitud de palabras (Jaccard)
            const set1 = new Set(tokens1.words);
            const set2 = new Set(tokens2.words);
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            const jaccard = union.size === 0 ? 0 : intersection.size / union.size;
            
            // 2. Jaro-Winkler alfab√©tico
            const jw = jaroWinkler(tokens1.normalized, tokens2.normalized);
            
            // 3. Similitud de caracteres (n-gramas)
            const charSim = characterSimilarity(text1, text2) / 100;
            
            // 4. Similitud de stems
            const stemSet1 = new Set(tokens1.stems);
            const stemSet2 = new Set(tokens2.stems);
            const stemInter = new Set([...stemSet1].filter(x => stemSet2.has(x)));
            const stemUnion = new Set([...stemSet1, ...stemSet2]);
            const stemSim = stemUnion.size === 0 ? 0 : stemInter.size / stemUnion.size;
            
            // 5. Similitud de bigramas
            const biSet1 = new Set(tokens1.bigrams);
            const biSet2 = new Set(tokens2.bigrams);
            const biInter = new Set([...biSet1].filter(x => biSet2.has(x)));
            const biUnion = new Set([...biSet1, ...biSet2]);
            const biSim = biUnion.size === 0 ? 0 : biInter.size / biUnion.size;
            
            // 6. Similitud fon√©tica
            let phoneticSim = 0;
            if (tokens1.words.length > 0 && tokens2.words.length > 0) {
                let totalPhonetic = 0;
                let count = 0;
                tokens1.words.forEach(w1 => {
                    tokens2.words.forEach(w2 => {
                        totalPhonetic += phoneticMatch(w1, w2);
                        count++;
                    });
                });
                phoneticSim = count > 0 ? totalPhonetic / count : 0;
            }
            
            // 7. Contenci√≥n (substring)
            let containsSim = 0;
            if (tokens1.normalized.includes(tokens2.normalized) || 
                tokens2.normalized.includes(tokens1.normalized)) {
                const shorter = Math.min(tokens1.normalized.length, tokens2.normalized.length);
                const longer = Math.max(tokens1.normalized.length, tokens2.normalized.length);
                containsSim = shorter / longer;
            }
            
            // Pesos optimizados para precisi√≥n
            const finalScore = (
                jaccard * 0.20 +
                jw * 0.20 +
                charSim * 0.15 +
                stemSim * 0.15 +
                biSim * 0.15 +
                phoneticSim * 0.10 +
                containsSim * 0.05
            ) * 100;
            
            return finalScore;
        }

        // ===== B√öSQUEDA Y MATCHING AVANZADO =====
        function findBestMatches(userInput) {
            calculateIDF();
            
            const matches = [];
            const userTokens = tokenize(userInput);
            const userKeywords = extractKeywords(userInput);
            const userTFIDF = calculateTFIDF(userTokens.words);
            
            trainingData.forEach((item, index) => {
                let score = 0;
                const analysis = {};
                
                // 1. Similitud avanzada pregunta
                const qSim = advancedSimilarity(userInput, item.question);
                score += qSim * 0.50;
                analysis.qSim = qSim;
                
                // 2. Similitud respuesta
                const aSim = advancedSimilarity(userInput, item.answer);
                score += aSim * 0.10;
                analysis.aSim = aSim;
                
                // 3. Keywords con TF-IDF
                let keywordScore = 0;
                userKeywords.forEach(uk => {
                    if (item.keywords.includes(uk)) {
                        const weight = userTFIDF[uk] || 1;
                        keywordScore += weight * 3;
                    }
                });
                score += Math.min(keywordScore, 20);
                analysis.keywords = keywordScore;
                
                // 4. Bigramas
                const biMatches = item.questionBigrams.filter(bg => 
                    userTokens.bigrams.includes(bg)
                ).length;
                score += biMatches * 8;
                analysis.bigrams = biMatches;
                
                // 5. Trigramas (m√°s peso)
                const triMatches = item.questionTrigrams.filter(tg => 
                    userTokens.trigrams.includes(tg)
                ).length;
                score += triMatches * 15;
                analysis.trigrams = triMatches;
                
                // 6. Estructura gramatical similar
                const userGrammar = analyzeGrammar(userInput);
                const itemGrammar = analyzeGrammar(item.question);
                if (userGrammar.isQuestion === itemGrammar.isQuestion) {
                    score += 5;
                }
                
                // 7. Historial de √©xito
                if (item.successCount > 0) {
                    const successRate = item.successCount / (item.successCount + item.failCount || 1);
                    score += successRate * 15;
                    analysis.success = successRate;
                }
                
                // 8. Contexto conversacional
                if (conversationContext.length > 0) {
                    conversationContext.forEach(ctx => {
                        const ctxSim = advancedSimilarity(ctx, item.question);
                        if (ctxSim > 40) {
                            score += 10;
                        }
                    });
                }
                
                if (score > 5) {
                    matches.push({ 
                        item, 
                        index, 
                        score: Math.min(score, 100),
                        analysis
                    });
                }
            });
            
            matches.sort((a, b) => b.score - a.score);
            return matches;
        }

        // ===== GENERACI√ìN DE RESPUESTA INTELIGENTE =====
        function generateSmartResponse(userInput, matches) {
            if (matches.length === 0) return null;
            
            const topMatches = matches.slice(0, 10).filter(m => m.score > 20);
            if (topMatches.length === 0) return null;
            
            // Buscar respuesta perfecta
            for (let match of topMatches.slice(0, 3)) {
                if (match.score > 70) {
                    const structScore = sentenceStructureScore(match.item.answer);
                    const hasLogic = hasLogicalSense(match.item.answer);
                    
                    if (structScore > 70 && hasLogic) {
                        const corrected = fullCorrection(match.item.answer);
                        return {
                            response: corrected.text,
                            combined: false,
                            sources: [match],
                            confidence: match.score,
                            coherence: 100,
                            logic: 100
                        };
                    }
                }
            }
            
            // An√°lisis profundo de oraciones
            const sentences = [];
            topMatches.forEach(match => {
                const answerSents = match.item.answer
                    .split(/[.!?]+/)
                    .map(s => s.trim())
                    .filter(s => s.length > 8);
                
                answerSents.forEach(sent => {
                    const relevance = advancedSimilarity(userInput, sent);
                    const structure = sentenceStructureScore(sent);
                    const logic = hasLogicalSense(sent) ? 100 : 0;
                    const grammar = analyzeGrammar(sent);
                    
                    if (logic > 0 && structure > 50) {
                        const weight = (
                            match.score * 0.30 +
                            relevance * 0.25 +
                            structure * 0.20 +
                            logic * 0.15 +
                            grammar.score * 0.10
                        );
                        
                        sentences.push({
                            text: sent,
                            weight: weight,
                            source: match,
                            relevance: relevance,
                            structure: structure,
                            logic: logic,
                            grammar: grammar
                        });
                    }
                });
            });
            
            if (sentences.length === 0) return null;
            
            // Eliminar duplicados
            const unique = [];
            sentences.forEach(sent => {
                const isDup = unique.some(u => advancedSimilarity(sent.text, u.text) > 80);
                if (!isDup) unique.push(sent);
            });
            
            unique.sort((a, b) => b.weight - a.weight);
            
            // Si la mejor es excelente, usarla
            if (unique[0].weight > 75 && unique[0].structure > 70) {
                const corrected = fullCorrection(unique[0].text);
                return {
                    response: corrected.text,
                    combined: false,
                    sources: [unique[0].source],
                    confidence: unique[0].weight,
                    coherence: 100,
                    logic: unique[0].logic
                };
            }
            
            // Combinar inteligentemente
            const selected = [unique[0]];
            let totalCoherence = 100;
            let totalLogic = unique[0].logic;
            
            for (let i = 1; i < Math.min(unique.length, 6); i++) {
                const candidate = unique[i];
                
                let compatible = true;
                let minCoherence = 100;
                
                for (let sel of selected) {
                    // Verificar contradicci√≥n
                    if (detectContradiction(sel.text, candidate.text)) {
                        compatible = false;
                        break;
                    }
                    
                    // Calcular coherencia
                    const cohScore = advancedSimilarity(sel.text, candidate.text);
                    minCoherence = Math.min(minCoherence, cohScore);
                    
                    if (cohScore < 35) {
                        compatible = false;
                        break;
                    }
                }
                
                if (compatible && minCoherence >= 35 && candidate.logic > 0) {
                    selected.push(candidate);
                    totalCoherence += minCoherence;
                    totalLogic += candidate.logic;
                    
                    if (selected.length >= 3) break;
                }
            }
            
            if (selected.length === 1) {
                const corrected = fullCorrection(selected[0].text);
                return {
                    response: corrected.text,
                    combined: false,
                    sources: [selected[0].source],
                    confidence: selected[0].weight,
                    coherence: 100,
                    logic: selected[0].logic
                };
            }
            
            // Combinar con conectores
            let combined = '';
            selected.forEach((sent, idx) => {
                if (idx === 0) {
                    combined += sent.text;
                } else {
                    const connectors = ['. Adem√°s, ', '. Tambi√©n, ', '. Por otro lado, ', '. Asimismo, '];
                    const conn = connectors[Math.floor(Math.random() * connectors.length)];
                    combined += conn + sent.text.charAt(0).toLowerCase() + sent.text.slice(1);
                }
            });
            
            const final = fullCorrection(combined);
            const avgCoherence = totalCoherence / (selected.length + 1);
            const avgLogic = totalLogic / selected.length;
            const avgWeight = selected.reduce((s, x) => s + x.weight, 0) / selected.length;
            
            if (avgCoherence < 40 || avgLogic < 50) {
                const corrected = fullCorrection(selected[0].text);
                return {
                    response: corrected.text,
                    combined: false,
                    sources: [selected[0].source],
                    confidence: selected[0].weight,
                    coherence: 100,
                    logic: selected[0].logic
                };
            }
            
            return {
                response: final.text,
                combined: true,
                sources: selected.map(s => s.source),
                confidence: avgWeight,
                coherence: avgCoherence,
                logic: avgLogic
            };
        }

        // ===== FUNCIONES DE INTERFAZ =====
        function trainAI() {
            const question = document.getElementById('question').value.trim();
            const answer = document.getElementById('answer').value.trim();
            const statusDiv = document.getElementById('trainStatus');

            if (!question || !answer) {
                statusDiv.innerHTML = '<div class="status error">Completa ambos campos</div>';
                return;
            }

            const qCorrected = fullCorrection(question);
            const aCorrected = fullCorrection(answer);
            
            const correctedQuestion = qCorrected.text;
            const correctedAnswer = aCorrected.text;

            const { words: qWords, stems: qStems, bigrams: qBigrams, trigrams: qTrigrams } = tokenize(correctedQuestion);
            const { words: aWords, stems: aStems, bigrams: aBigrams, trigrams: aTrigrams } = tokenize(correctedAnswer);
            const keywords = extractKeywords(correctedQuestion + ' ' + correctedAnswer);
            
            trainingData.push({
                id: Date.now() + Math.random(),
                question: correctedQuestion,
                answer: correctedAnswer,
                questionNorm: normalizeText(correctedQuestion),
                answerNorm: normalizeText(correctedAnswer),
                questionWords: qWords,
                answerWords: aWords,
                questionStems: qStems,
                answerStems: aStems,
                questionBigrams: qBigrams,
                answerBigrams: aBigrams,
                questionTrigrams: qTrigrams,
                answerTrigrams: aTrigrams,
                keywords,
                successCount: 0,
                failCount: 0,
                useCount: 0,
                timestamp: new Date().toISOString()
            });

            try {
                localStorage.setItem('aiTrainingData', JSON.stringify({
                    trainingData: trainingData,
                    questionCount: questionCount
                }));
            } catch(e) {}

            statusDiv.innerHTML = '<div class="status success">‚úì Entrenamiento completado con an√°lisis multinivel</div>';
            document.getElementById('question').value = '';
            document.getElementById('answer').value = '';
            
            updateStats();
            viewTraining();
        }

        function askAI() {
            const userInput = document.getElementById('userQuestion').value.trim();
            const responseDiv = document.getElementById('aiResponse');
            const analysisDiv = document.getElementById('analysis');
            const feedbackDiv = document.getElementById('feedbackSection');

            if (!userInput) {
                responseDiv.innerHTML = '<div class="status error">Escribe una pregunta</div>';
                return;
            }

            questionCount++;

            if (trainingData.length === 0) {
                responseDiv.innerHTML = '<div class="status info">‚ö†Ô∏è Primero entrena la IA</div>';
                return;
            }

            const corrected = fullCorrection(userInput);
            const matches = findBestMatches(corrected.text);

            if (matches.length === 0 || matches[0].score < 15) {
                responseDiv.innerHTML = '<div class="status warning">ü§î No encontr√© informaci√≥n relevante. Entrena m√°s la IA.</div>';
                analysisDiv.innerHTML = '';
                feedbackDiv.innerHTML = '';
                return;
            }

            const result = generateSmartResponse(corrected.text, matches);
            
            if (!result) {
                responseDiv.innerHTML = '<div class="status warning">‚ö†Ô∏è No pude generar una respuesta l√≥gica y coherente.</div>';
                analysisDiv.innerHTML = `
                    <div class="analysis">
                        <strong>üîç An√°lisis:</strong><br>
                        <div class="analysis-item">‚Ä¢ ${matches.length} fuentes encontradas</div>
                        <div class="analysis-item">‚Ä¢ Mejor coincidencia: ${matches[0].score.toFixed(0)}%</div>
                        <div class="analysis-item">‚Ä¢ Problema: No se pudo validar l√≥gica y coherencia</div>
                    </div>
                `;
                return;
            }

            lastUsedSources = result.sources.map(s => s.index);
            
            let qualityColor = result.logic > 80 ? '#4caf50' : result.logic > 50 ? '#ff9800' : '#f44336';
            
            let html = `
                <div style="color: #155724;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                        <strong style="font-size: 1.1em;">ü§ñ Respuesta IA:</strong>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <span class="match-score">${result.confidence.toFixed(0)}% precisi√≥n</span>
                            ${result.combined ? '<span class="combined-badge">üîÄ COMBINADA</span>' : '<span class="combined-badge" style="background: #2196F3;">‚úì DIRECTA</span>'}
                            <span class="coherence-badge" style="background: ${qualityColor};">üß† ${result.logic.toFixed(0)}% l√≥gica</span>
                        </div>
                    </div>
                    <div class="generated-response">
                        ${result.response}
                    </div>
            `;
            
            if (result.sources.length > 0) {
                html += '<div class="source-list"><strong>üìö Fuentes:</strong>';
                result.sources.forEach((source, idx) => {
                    html += `
                        <div class="source-item">
                            <span class="source-weight">#${idx + 1} ${source.score.toFixed(0)}%</span>
                            "${source.item.question}"
                        </div>
                    `;
                });
                html += '</div>';
            }
            
            html += '</div>';
            responseDiv.innerHTML = html;
            
            feedbackDiv.innerHTML = `
                <div class="feedback-btns">
                    <button class="feedback-btn feedback-good" onclick="giveFeedback(true)">üëç √ötil</button>
                    <button class="feedback-btn feedback-bad" onclick="giveFeedback(false)">üëé Incorrecta</button>
                </div>
            `;
            
            analysisDiv.innerHTML = `
                <div class="analysis">
                    <strong>üî¨ An√°lisis Multinivel:</strong><br>
                    <div class="analysis-item">‚Ä¢ ${matches.length} fuentes analizadas</div>
                    <div class="analysis-item">‚Ä¢ ${result.sources.length} fuentes usadas</div>
                    <div class="analysis-item">‚Ä¢ Precisi√≥n: ${result.confidence.toFixed(0)}%</div>
                    <div class="analysis-item">‚Ä¢ Coherencia: ${result.coherence.toFixed(0)}%</div>
                    <div class="analysis-item">‚Ä¢ Validaci√≥n l√≥gica: ${result.logic.toFixed(0)}%</div>
                    <div class="analysis-item">‚Ä¢ M√©todos: Alfab√©tico, Jaro-Winkler, N-gramas, TF-IDF, Gramatical, Fon√©tico, L√≥gico</div>
                </div>
            `;
            
            conversationContext.push(corrected.text);
            if (conversationContext.length > 5) conversationContext.shift();
            
            updateStats();
        }

        function giveFeedback(isPositive) {
            if (lastUsedSources.length === 0) return;
            
            lastUsedSources.forEach(idx => {
                if (trainingData[idx]) {
                    trainingData[idx].useCount++;
                    if (isPositive) {
                        trainingData[idx].successCount++;
                    } else {
                        trainingData[idx].failCount++;
                    }
                }
            });
            
            try {
                localStorage.setItem('aiTrainingData', JSON.stringify({
                    trainingData: trainingData,
                    questionCount: questionCount
                }));
            } catch(e) {}
            
            document.getElementById('feedbackSection').innerHTML = `
                <div class="status success">
                    ${isPositive ? '‚úì ¬°Gracias! Mejorando IA' : '‚úì Registrado, ajustando algoritmo'}
                </div>
            `;
        }

        function deleteTraining(id) {
            if (!confirm('¬øEliminar?')) return;
            trainingData = trainingData.filter(item => item.id !== id);
            try {
                localStorage.setItem('aiTrainingData', JSON.stringify({
                    trainingData: trainingData,
                    questionCount: questionCount
                }));
            } catch(e) {}
            updateStats();
            viewTraining();
        }

        function downloadTraining() {
            if (trainingData.length === 0) {
                alert('No hay datos para descargar');
                return;
            }
            const data = JSON.stringify({
                version: '3.0-advanced',
                trainingData: trainingData,
                questionCount: questionCount
            }, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ia-v3-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadTraining(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    trainingData = data.trainingData || [];
                    questionCount = data.questionCount || 0;
                    try {
                        localStorage.setItem('aiTrainingData', JSON.stringify({
                            trainingData: trainingData,
                            questionCount: questionCount
                        }));
                    } catch(err) {}
                    updateStats();
                    viewTraining();
                    alert(`‚úì ${trainingData.length} entrenamientos cargados`);
                } catch(error) {
                    alert('Error al cargar archivo');
                }
            };
            reader.readAsText(file);
        }

        function clearAllTraining() {
            if (!confirm('¬øBorrar todo el entrenamiento?')) return;
            trainingData = [];
            questionCount = 0;
            conversationContext = [];
            try {
                localStorage.removeItem('aiTrainingData');
            } catch(e) {}
            updateStats();
            viewTraining();
        }

        function viewTraining() {
            const listDiv = document.getElementById('trainingList');
            if (trainingData.length === 0) {
                listDiv.innerHTML = '<div class="status info">Sin datos de entrenamiento</div>';
                return;
            }
            listDiv.innerHTML = trainingData.map(item => `
                <div class="training-item">
                    <div class="training-content">
                        <strong>P:</strong> ${item.question}<br>
                        <strong>R:</strong> ${item.answer}<br>
                        <small style="color: #666;">Usos: ${item.useCount} | ‚úì${item.successCount} ‚úó${item.failCount}</small>
                    </div>
                    <button class="btn-delete" onclick="deleteTraining('${item.id}')">üóëÔ∏è</button>
                </div>
            `).join('');
        }

        function updateStats() {
            document.getElementById('totalTraining').textContent = trainingData.length;
            document.getElementById('totalQuestions').textContent = questionCount;
            const allWords = new Set();
            trainingData.forEach(item => {
                item.questionWords.forEach(w => allWords.add(w));
                item.answerWords.forEach(w => allWords.add(w));
            });
            document.getElementById('totalWords').textContent = allWords.size;
            const size = new Blob([JSON.stringify(trainingData)]).size;
            document.getElementById('dbSize').textContent = (size / 1024).toFixed(2) + ' KB';
        }

        window.addEventListener('load', () => {
            try {
                const saved = localStorage.getItem('aiTrainingData');
                if (saved) {
                    const data = JSON.parse(saved);
                    trainingData = data.trainingData || [];
                    questionCount = data.questionCount || 0;
                }
            } catch(e) {}
            updateStats();
            viewTraining();
        });
    </script>
</body>
</html>